Para iniciar um projeto com NextJs
pode ser pelo npx ou yarn a diferença é que yarn é mais rápida a instalação.
 
Tem que instalar o instalador yarn antes com
npm install --global yarn
O comando Shift + Alt + F
 indentação automática

--------------------------
Verifique:
yarn --version


Podendo ainda acrescentar --typescript

npx create-next-app@latest <nome> --typescript
ou
yarn create next-app <nome> --typescript

Ctrl + ' 
No terminal do VSCode:
npx create-next-app@latest tarefas --typescript

create-next-app@13.2.4
Ok to proceed? (y)

Would you like to use ESLint with this project? » No / Yes
Neste projeto "No"

Would you like to use `src/` directory with this project? » No / Yes
Prefiro que inicie com a pasta src- Yes

Would you like to use experimental `app/` directory with this project? » No / Yes
No

What import alias would you like configured? » @/*
dar enter



=====================================

npm install next-auth     Para autenticações: https://next-auth.js.org/getting-started/example e https://next-auth.js.org/providers/google
yarn add react-icons
yarn add firebase

=====================================


-----------------@
cd tarefas
-----------------@


---------------
Em src/pages deixar somente
_app.tsx 
e
index.tsx
---------------
Deixar a pasta styles fora de src



---------------
Em src/pages/index.tsx:


import Head from 'next/head'
import styles from '../../styles/home.module.css'

export default function Home() {
  return (
    <div className={styles.container}>
      <Head>
        <title>Tarefas+ | Organize de forma fácil</title>        
      </Head>
      <h1>Projeto Tarefas com Next</h1> 
      
    </div>
  )
}


--------corrigir nome na pasta styles
para h minúnculo home.module.css e apagar tudo

Em globals.css também apagar tudo, ele está sendo chamado em pages/_app.tsx

----Em pages/_app.tsx corrigir importação do globals.css:

import '../../styles/globals.css';
import type { AppProps } from 'next/app';

export default function App({ Component, pageProps }: AppProps) {
  return <Component {...pageProps} /> {/*Aqui é o corpo da página */}
}


-------Testar:
npm run dev
ou
yarn dev

---------Fazer as configurações iniciais em globals.css:


/*Pode importar uma fonte global: 
https://fonts.google.com/specimen/Roboto
e chamar em html como primeira opção:*/
@import url('https://fonts.googleapis.com/css2?family=Roboto:wght@500&display=swap');

*{
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

html{
    font-family: "roboto", sans-serif;
}


------------
Em public/assets
para inserir as midias que serão utilizadas.

------------------------------------------------
------------------------------------------------
Em pages/index.tsx:


import Head from 'next/head'
import styles from '../../styles/home.module.css'

//Pode usar <img> se quiser, mas o Next tem um modelo que carrega melhor, tem mais performance. Image
import Image from 'next/image';
import homeimage from '../../public/assets/home-image.jpg';
// Pode priorizar o carregamento escrevendo apenas priority. Não precisa ser priority={true}

export default function Home() {
  return (
    <div className={styles.container}>
      <Head>
        <title>Tarefas+ | Organize de forma fácil</title>        
      </Head>
      <main className={styles.main}>
        <div className={styles.logoContent}>
          <Image  className={styles.homeimage}
                  alt="Logo Tarefas"
                  src={homeimage}
                  priority={true}
          />
        </div>
        <h1 className={styles.title}>
          Organize seus estudos e outras tarefas
          <br/>do dia a dia.
        </h1>
      </main>
      
    </div>
  )
}



---------------Estilizar isso em home.module.css:

.container{
    background-color: #0f0f0f;
    width: 100%;
    height: 100vh; /*para ocupar a tela toda*/
    display: flex;
    justify-content: center;
    align-items: center;
    flex-direction: column;
}

.logoContent{
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
}

.homeimage{
    max-width: 480px;
    object-fit: contain; /* Vai encaixar na largura sem distorcer */
    width: auto;
    height: auto;    
    border-radius: 10px;    
}

.title{
    color: #fff;
    text-align: center;
    margin: 28px;
    line-height: 150%;
}


----------------------Criar cabeçalho e botões abaixo da imagem
em pages/index.tsx:


import Head from 'next/head'
import styles from '../../styles/home.module.css'

//Pode usar <img> se quiser, mas o Next tem um modelo que carrega melhor, tem mais performance. Image
import Image from 'next/image';
import homeimage from '../../public/assets/home-image.jpg';
// Pode priorizar o carregamento escrevendo apenas priority. Não precisa ser priority={true}

export default function Home() {
  return (
    <div className={styles.container}>
      <Head>
        <title>Tarefas+ | Organize de forma fácil</title>        
      </Head>
      <main className={styles.main}>
        <div className={styles.logoContent}>
          <Image  className={styles.homeimage}
                  alt="Logo Tarefas"
                  src={homeimage}
                  priority={true}
          />
        </div>
        <h1 className={styles.title}>
          Organize seus estudos e outras tarefas
          <br/>do dia a dia.
        </h1>

        <div className={styles.infoContent}>
          <section className={styles.box}>
            <span>+12 posts</span>
          </section>

          <section className={styles.box}>
            <span>+5 comentários</span>
          </section>
        </div>

      </main>
      
    </div>
  )
}



---------------Estilizar botões isso em home.module.css:     FICOU TOP !!!


.container{
    background-color: #0f0f0f;
    width: 100%;
    /* height: 100vh; para ocupar a tela toda, mas precisa descontar o tamanho total do cabeçalho para evitar barra de rolagem lateral*/
    height: calc(100vh - 75px);
    display: flex;
    justify-content: center;
    align-items: center;
    flex-direction: column;
}

.logoContent{
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
}

.homeimage{
    max-width: 480px;
    object-fit: contain; /* Vai encaixar na largura sem distorcer */
    width: auto;
    height: auto;    
    border-radius: 10px;    
}

.title{
    color: #fff;
    text-align: center;
    margin: 28px;
    line-height: 150%; /* espaçamento vertical*/
}

.infoContent{
    display: flex; /* Já coloca um ao lado do outro*/
    align-items: center;
    justify-content: space-around; /* Espaço entre intens */
}

.box{
    background-color: #fafafa;
    padding: 15px 45px;
    border-radius: 5px;
    transition: transform 0.3s;
}

.box:hover{
    transform: scale(1.08);
}

/* Caso o aparelho seja muito pequeno pode usar o media query */
@media screen and (max-width: 580px){
    .homeimage{
        max-width: 80% ;
    }

    .title{
        font-size: 20px;
    }
    .infoContent{
        flex-direction: column;
    }
    .box{
        width: 80%;
        margin-bottom: 14px;
        text-align: center;
    }
}




-------------Criar src/components/header/index.tsx:



import styles from './styles.module.css';

export function Header(){
    return(
        <header>
            <section>
                <nav>
                    <h1>Tarefas+</h1>

                </nav>
            </section>
        </header>
    )
}


/********* Esse cabeçalho pode ser importado para todas as páginas
através do pages/_app.tsx   
*/




-------------Atualizar pages/_app.tsx:


import '../../styles/globals.css';
import type { AppProps } from 'next/app';
import { Header } from '../components/header';

export default function App({ Component, pageProps }: AppProps) {
  return (
    <>
      <Header/>
      <Component {...pageProps} /> {/*Aqui é o corpo da página */}
      
    </>
  );
}


/*  LEMBRE-SE QUE PARA MAIS DE 1 ITEM PRECISA POR EM () 
export default function App({ Component, pageProps }: AppProps) {
  return <Component {...pageProps} />   <-----------------AQUI
}
*/




-------------Atualizar src/components/header/index.tsx:



import styles from './styles.module.css';

export function Header(){
    return(
        <header>
            <section>
                <nav>
                    <h1>Tarefas+</h1>

                </nav>
            </section>
        </header>
    )
}


-------------
Atualizar novamente:


import styles from './styles.module.css';

/* Para usar navegação importar Link */
import Link from 'next/link';

export function Header(){
    return(
        <header className={styles.header}>
            <section className={styles.content}>
                <nav className={styles.nav}>
                    <Link href='/'>
                        <h1 className={styles.logo}>
                            Tarefas<span>+</span>
                        </h1>
                    </Link>
		    
		    <Link href='/dashboard' 
                    className={styles.link}>
                        Painel
                    </Link>

                </nav>

		<button className={styles.loginButton}>Minha conta</button>

            </section>
        </header>
    )
}
/********* Esse cabeçalho pode ser importado para todas as páginas
através do pages/_app.tsx   
*/







-------------Criar src/components/header/styles.module.css:

.header{
    width: 100%;
    height: 75px;     /* ESSA É A ALTURA DO CABEÇALHO. para evitar barra de rolgagem lateral foi usado height: calc(100vh - 75px); em home.modules.css */
    background-color: #0f0f0f;
    display: flex;
    align-items: center;
    justify-content: center;
}

.content{
    padding: 0 18px;
    width: 100%;
    max-width: 1024px; /* Interessante colocar isso para não ficar muito largo em telas maiores */
    display: flex;
    align-items: center;
    justify-content: space-between; /* vai separar os botões */
}

.content a{
    text-decoration: none;
}

.logo{
    color: #fff;
    font-size: 32px;
}

.logo span{
    color: #ea3140;
    padding: 3px;
}

.loginButton{
    background: transparent;
    padding: 8px 35px;
    border-radius: 25px;
    color: #fff;
    border: 1.5px solid #fff; /* Lembre-se de por solid */
    cursor: pointer;
    transition: all 0.3s;
}

.loginButton:hover{
    transform: scale(1.08);
    background-color: #fff;
    color: #0f0f0f;
    font-weight: bold;
}

.nav{
    display: flex;
    align-items: center;
}

.link{
    background-color: #f1f1f1;
    color: #0f0f0f;
    padding: 5px 15px;
    border-radius: 5px;
    margin: 0 15px;
}



**************************************************
------------------Sistemas de login real com gmail

--------Criar pages/dashboard/index.tsx:


/* Lembrando que sempre que for PÁGINA tem que que usar DEFAULT */

import styles from './styles.module.css';
import Head from 'next/head';

export default function Dashboard(){
    return(
        <div className={styles.container}>
            <Head>
                <title>Painel de tarefas</title>
            </Head>  
            <h1>Página Painel</h1>          
        </div>
    )
}



------------------PARA TRABALHAR COM AUTENTICAÇÃO USAR UMA BIBLIOTECA CHAMADA 
NextAuth.js

Veja na coluna E em providers a 
quantidade de autenticações possíveis em:
https://next-auth.js.org/providers/

Veja em Getting Started como iniciar:
https://next-auth.js.org/getting-started/example

 
Instalar o pacote de eutenticação:

yarn add next-auth
ou
npm install next-auth

*No site mostra que exemplo que tem que por provider ao redor da aplicação 
pages/_app.jsx
import { SessionProvider } from "next-auth/react"
e pode preencher o fragment com isso.

Pede também para passar a session <SessionProvider session={session}>

--------------------------------Vai ficar assim
Em pages/_app.tsx:

import '../../styles/globals.css';
import type { AppProps } from 'next/app';
import { Header } from '../components/header';

// Autenticação de email para acesso
import { SessionProvider } from "next-auth/react"

export default function App({ Component, pageProps }: AppProps) {
  return (
    <SessionProvider session={pageProps.session}>
      <Header/>
      <Component {...pageProps} />{/*Aqui é o corpo da página */}
      
    </SessionProvider>
  );
}



&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Está tudo na documentação

-------https://next-auth.js.org/getting-started/example
ainda pede para iniciar em 
pages/api/auth/[...nextauth].js     Criar exatamente assim com os colchetes

***** Por estar usando NEXT a exstenção será .ts   *****


No site ir em providers e ver quais serão utilisadas:
 https://next-auth.js.org/providers/google


Configuration (Para gerar as credenciais)
https://console.developers.google.com/apis/credentials

Abrir: + CRIAR CREDENCIAIS / ID do cliente do OAuth / 
CONFIGURAR TELA DE CONSENTIMENTO
Externo
CRIAR

Nome do app ( AQUI VAI APARECER PARA O USUÁRIO QUANDO FOR FAZER O LOGIN)


O nome do aplicativo que precisa da permissão
E-mail para suporte do usuário
leandrocf79@gmail.com

Ainda não tem as páginas, usar localhost por enquanto em
Domínio do app:
---
Página inicial do aplicativo
http://localhost:3000/
Forneça aos usuários um link para sua página inicial
Link da Política de Privacidade do aplicativo
http://localhost:3000/
Forneça aos usuários um link para sua Política de Privacidade pública
Link dos Termos de Serviço do aplicativo
http://localhost:3000/
Forneça aos usuários um link para seus Termos de Serviço públicos
---

Domínios autorizados
deixar como estiver lá

Dados de contato do desenvolvedor
Endereços de e-mail 
leandrocf79@gmail.com

	
SALVAR E CONTINUAR

--------
Clicar em ADICIONAR OU REMOVER ESCOPOS

** Por enquanto pode marcar somente:
[v] See your primary Google Account email address
[v] See your personal info, including any personal info you've made publicly available

ATUALIZAR

SALVAR E CONTINUAR até o fim

-------------
-----Na coluna da Esquerda tem Credenciais. Precisa gerar ID

+ CRIAR CREDENCIAIS / ID do cliente do OAuth


Tipo de aplicativo
Aplicativo da Web


Nome
Next Projeto Tarefas

por enquanto:
Origens JavaScript autorizadas
Para usar com solicitações de um navegador
URIs 1 
http://localhost:3000

---Redirecionamento

URIs de redirecionamento autorizados
Para usar com solicitações de um servidor da Web
URIs 1 
http://localhost:3000/api/auth/callback/google      <---Foi sugerido no: https://next-auth.js.org/providers/google 

CRIAR


-------Neste momento será gerada a API

***Valores abaixo são demonstrativos***

ID do cliente
948545454545769-74d2ck45454545u7e6fapps.googleusercontent.com

Chave secreta do cliente
G45545PX-d545454aVon_eg678678678JM6M7sdfsAcwrEAv

Data da criação
16 de março de 2023 18:55:38 GMT-3

Status
Ativada

--------------------------------
Na raiz projeto, fora de qualquer diretório, criar 
uma variável ambinete chamda .env
Basta clicar fora de qualquer texto

-----------
DAR NOMES com letras maiúsculas e com Underline, SUGESTÃO:
GOOGLE_CLIENT_ID=
GOOGLE_CLIENT_SECRET=
-
Passar o site.  
-
Criar uma JWT secret para ajudar na criptografia. 
Para gerar uma é nteressante usar o site: https://www.md5hashgenerator.com/
digitar algo e gerar
copiar a MD5 Hash que foi gerada E COLAR EM "JWT_SECRET="

-----------
Agora no .env:

GOOGLE_CLIENT_ID=948545454545769-74d2ck45454545u7e6fapps.googleusercontent.com
GOOGLE_CLIENT_SECRET=G45545PX-d545454aVon_eg678678678JM6M7sdfsAcwrEAv

NEXTAUTH_URL=http://localhost:3000

JWT_SECRET=5aeiou55blabla


&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Tudo configurado. Agora ir em [...nextauth].ts :


import NextAuth from "next-auth/next";
import GoogleProvider from 'next-auth/providers/google';

export const authOptions ={
    providers:[
        GoogleProvider({
            clientId: process.env.GOOGLE_CLIENT_ID as string,
            clientSecret: process.env.GOOGLE_CLIENT_SECRET as string
        })
    ], secret: process.env.JWT_SECRET as string
}

export default NextAuth(authOptions); //Passar para ser carregada


--------------------------------
--------------------------------
---------O SISTEMA DE LOGIN ESTÁ NO HEADER no botão "Minha conta"
Em components/header/index.tsx:

useSession - Para saber se está logado.





import styles from './styles.module.css';

//SISTEMA DE LOGIN
import { useSession, signIn, signOut } from 'next-auth/react';

/* Para usar navegação importar Link */
import Link from 'next/link';

export function Header(){
    //SISTEMA DE LOGIN. Criar o Hook
    const {data: session, status} = useSession();


    return(
        <header className={styles.header}>
            <section className={styles.content}>
                <nav className={styles.nav}>
                    <Link href='/'>
                        <h1 className={styles.logo}>
                            Tarefas<span>+</span>
                        </h1>
                    </Link>
		
		
	{/* Essa parte será substituida!! */}
                    <Link href='/dashboard' 
                    className={styles.link}>
                        Painel
                    </Link>


                </nav>

                {/*SISTEMA DE LOGIN */}
                { status === 'loading' ? (
                    <></>
                ): session ? (
                    <>
                        <div className={styles.loginName}>Olá {session?.user?.name}</div>
                        <button className={styles.loginButton} onClick={ ()=> signOut() }> {/* Se estiver logado */}
                            Sair                  
                        </button>
                        
                    </>
                ):(
                    <button className={styles.loginButton} onClick={ ()=> signIn('google') }> {/* Se NÃO estiver logado. Esta utilizando um PROVIDER que é do google precisa informar que vai usar */}
                        Minha conta                 
                    </button>
                )}

                

            </section>
        </header>
    )
}
/********* Esse cabeçalho pode ser importado para todas as páginas
através do pages/_app.tsx   
*/





------------Só isso acima !!!

Atualizei o styles.modules.css com
.loginName{
    color: #fff;
}



------------------------------------
------------------------------------Em header/index.tsx:
O botão "Meu painel" no cabeçalho é da página dashboard, precisa deixá-la no modo privado.

Essa é a primeira parte:

Substituir por essa parte!!


                    {session?.user && (  
                        <Link  href='/dashboard' 
                            className={styles.link}>
                            Painel
                        </Link>
                        )}




Agora precisa proteger o link /dashboard no navegador, se tentar 
acessar de forma anônima no navegador
http://localhost:3000/dashboard
vai acessar normalmente


&&&&&&&&&&&&&&&&&&&&&&&&&
 Poderia fazer a verificação do link dessa forma abaixo, mas
será apresentada outra forma adiante.

Para bloquear o acesso à página dashboard apenas para usuários 
autenticados, você precisa verificar se existe uma sessão ativa 
e redirecionar o usuário para a página de login caso contrário. 
Você pode fazer isso usando o componente useEffect para verificar 
a sessão e redirecionar o usuário se necessário. 
Aqui está um exemplo:

import { useRouter } from 'next/router';
import { useEffect } from 'react';
import { useSession } from 'next-auth/client';
import styles from './Header.module.css';

export default function Header() {
  const [session, loading] = useSession();
  const router = useRouter();

  useEffect(() => {
    if (!loading && !session) {
      router.push('/login');
    }
  }, [loading, session, router]);

  return (
    <header className={styles.header}>
      <nav className={styles.nav}>
        <Link href="/">
          <h1 className={styles.logo}>Tarefas</h1>
        </Link>
        {session?.user && (
          <Link href="/dashboard" className={styles.link}>
            Painel
          </Link>
        )}
      </nav>
      {session ? (
        <button onClick={() => signOut()}>Sair</button>
      ) : (
        <button onClick={() => signIn()}>Entrar</button>
      )}
    </header>
  );
}

Observe que verificamos se a sessão existe antes de renderizar o 
link para a página dashboard. Além disso, usamos o useEffect 
para verificar a sessão e redirecionar o usuário para a 
página de login se necessário.

&&&&&&&&&&&&&&&&&&&&&&&&&


Segundo modo.

Em pages/dashboard/index.tsx:





/* Lembrando que sempre que for PÁGINA tem que que usar DEFAULT */

import styles from './styles.module.css';
import Head from 'next/head';
import { GetServerSideProps } from 'next';
import { getSession } from 'next-auth/react';

export default function Dashboard(){
    return(
        <div className={styles.container}>
            <Head>
                <title>Painel de tarefas</title>
            </Head>  
            <h1>Página Painel</h1>          
        </div>
    )
}

//proteger o link /dashboard no navegador. Server Side é sempre executado no lado do SERVIDOR.

export const getServerSideProps: GetServerSideProps =async ( {req} ) => {//Escreva ""req"" de requisição. Importante ser apenas essas 3 letras
    //console.log("Buscando pelo server side"); //Veja no   TERMINAL
    //importar getSession para não ter que usar useEffect
    const session = await getSession( {req} );
    //console.log(session); //Veja no   TERMINAL
    if( !session?.user ){
        //Se não tem user, vá para home
        return{
            redirect: {
                destination: '/', //Home
                permanent: false
            },
        };

    }

    return{
        props:{},
    }
}







acessar de forma anônima no navegador não vai mais conseguir acesso
http://localhost:3000/dashboard


*******************Acessar com uma conta para visualizar as alterações no painel, dashboard.

------Criar components/textarea/index.tsx:

import styles from './styles.module.css';

export function Textarea(){
    return <textarea className={styles.textarea}></textarea>
}

------
Em pages/dashboard/index.tsx:




/* Lembrando que sempre que for PÁGINA tem que que usar DEFAULT */

import styles from './styles.module.css';
import Head from 'next/head';
import { GetServerSideProps } from 'next';
import { getSession } from 'next-auth/react';

//visualizar as alterações no painel
import { Textarea } from '@/components/textarea';

export default function Dashboard(){
    return(
        <div className={styles.container}>
            <Head>
                <title>Painel de tarefas</title>
            </Head>  

            {/* visualizar as alterações no painel */}
            <main className={styles.main}>
                <section className={styles.content}>
                    <div className={styles.contentForm}>
                        <h1 className={styles.title}>Qual sua tarefa?</h1>
                        <form> {/*Criado o components/textarea para aproveitar esse formulários e trocar apenas o conteúdo textarea dele  */}
                            <Textarea/>

                            <div className={styles.checkboxArea}>
                                <input type="checkbox"
                                    className={styles.checkbox}                                
                                />
                                <label>Deixar tarefa publica?</label>
                            </div>
                            <button type='submit' className={styles.button}>
                                Registrar
                            </button>
                        </form>
                    </div>
                </section>            
            </main>  

        </div>
    )
}

//proteger o link /dashboard no navegador. Server Side é sempre executado no lado do SERVIDOR.

export const getServerSideProps: GetServerSideProps =async ( {req} ) => {//Escreva ""req"" de requisição. Importante ser apenas essas 3 letras
    //console.log("Buscando pelo server side"); //Veja no   TERMINAL
    //importar getSession para não ter que usar useEffect
    const session = await getSession( {req} );
    //console.log(session); //Veja no   TERMINAL
    if( !session?.user ){
        //Se não tem user, vá para home
        return{
            redirect: {
                destination: '/', //Home
                permanent: false
            },
        };

    }

    return{
        props:{},
    }
}


----------Estilizar em pages/dashboard/styles.module.css:
Precisa estilizar após esse o components/textarea/styles.module.css.




.container{
    width: 100%;
}

.content{
    background-color: #0f0f0f;
    width: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
}

.contentForm{
    max-width: 1024px;
    width: 100%;
    padding: 0 18px;
    padding-bottom: 28px;
    margin-top: 58px;
}

.title{
    color: #fff;
    margin-bottom: 8px;
}

/*visualizar as alterações no painel*/

.checkboxArea label{
    color: #fff;
    margin-left: 8px;
}

.checkboxArea{
    margin: 14px;
}

.checkbox{
    width: 18px;
    height: 18px;
}

.button{
    width: 100%;
    border: 0;
    border-radius: 5px;
    color: #fff;
    background-color: #3183ff;
    padding: 10px 0;
    font-size: 18px;
}




----------- components/textarea/styles.module.css:

.textarea{
    width: 100%;
    resize: none;
    height: 160px;
    border-radius: 5px;
    outline: none; /*remover a "contorno" padrão que aparece em torno de um elemento */
    padding: 8px;
}



------Atualizar components/textarea/index.tsx:
O objetivo aqui é deixar esse textarea dinâmico para poder ser usado em vários locais



import styles from './styles.module.css';
import { HTMLProps } from 'react';

// ...rest - pegar todas as propriedades e dizer que só pode receber HTMLProps<> do tipo <HTMLTextAreaElement>
export function Textarea( {...rest}: HTMLProps<HTMLTextAreaElement> ){
    return <textarea className={styles.textarea} {...rest}></textarea>;
} // Repassando propriedades em   {...rest}></textarea>




-------------------Agora atualizar <Textarea/> em
pages/dashboard/index.tsx:

<Textarea placeholder='Digite sua tarefa...' />



-------------------Agora criar a parte de listas em
pages/dashboard/index.tsx:



/* Lembrando que sempre que for PÁGINA tem que que usar DEFAULT */

import styles from './styles.module.css';
import Head from 'next/head';
import { GetServerSideProps } from 'next';
import { getSession } from 'next-auth/react';

//criar a parte de listas
import { FiShare2 } from 'react-icons/fi';
import { FaTrash } from 'react-icons/fa';

//visualizar as alterações no painel
import { Textarea } from '@/components/textarea';

export default function Dashboard(){
    return(
        <div className={styles.container}>
            <Head>
                <title>Painel de tarefas</title>
            </Head>  

            {/* visualizar as alterações no painel */}
            <main className={styles.main}>
                <section className={styles.content}>
                    <div className={styles.contentForm}>
                        <h1 className={styles.title}>Qual sua tarefa?</h1>
                        <form> {/*Criado o components/textarea para aproveitar esse formulários e trocar apenas o conteúdo textarea dele  */}
                            <Textarea
                                placeholder='Digite sua tarefa...'                            
                            />

                            <div className={styles.checkboxArea}>
                                <input type="checkbox"
                                    className={styles.checkbox}                                
                                />
                                <label>Deixar tarefa publica?</label>
                            </div>
                            <button type='submit' className={styles.button}>
                                Registrar
                            </button>
                        </form>
                    </div>
                </section>  

                {/*criar a parte de listas */}
                <section className={styles.taskContainer}>
                    <h1>Minhas tarefas</h1>

                    <article className={styles.task}>
                        <div className={styles.tagContainer}>
                            <label className={styles.tag}>PÚBLICO</label>
                            <button className={styles.shareButton}>
                                <FiShare2
                                    size={22}
                                    color="#3183ff"

                                />
                            </button>
                        </div>

                        <div className={styles.taskContent}>
                            <p>Minha primeira tarefa</p>
                            <button className={styles.trashButton}>
                                <FaTrash size={22}
                                color='#ea3140'/>
                            </button>
                        </div>
                    </article>
                </section>

            </main>  

        </div>
    )
}

//proteger o link /dashboard no navegador. Server Side é sempre executado no lado do SERVIDOR.

export const getServerSideProps: GetServerSideProps =async ( {req} ) => {//Escreva ""req"" de requisição. Importante ser apenas essas 3 letras
    //console.log("Buscando pelo server side"); //Veja no   TERMINAL
    //importar getSession para não ter que usar useEffect
    const session = await getSession( {req} );
    //console.log(session); //Veja no   TERMINAL
    if( !session?.user ){
        //Se não tem user, vá para home
        return{
            redirect: {
                destination: '/', //Home
                permanent: false
            },
        };

    }

    return{
        props:{},
    }
}




--------------------------Estilizar dashboard:



.container{
    width: 100%;
}

.content{
    background-color: #0f0f0f;
    width: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
}

.contentForm{
    max-width: 1024px;
    width: 100%;
    padding: 0 18px;
    padding-bottom: 28px;
    margin-top: 58px;
}

.title{
    color: #fff;
    margin-bottom: 8px;
}

/*visualizar as alterações no painel*/
.checkboxArea label{
    color: #fff;
    margin-left: 8px;
}

.checkboxArea{
    margin: 14px;
}

.checkbox{
    width: 18px;
    height: 18px;
}

.button{
    width: 100%;
    border: 0;
    border-radius: 5px;
    color: #fff;
    background-color: #3183ff;
    padding: 10px 0;
    font-size: 18px;
}

/*criar a parte de listas*/

.taskContainer{
    margin: 34px auto 0 auto;
    padding: 0 18px;
    width: 100%;
    max-width: 1024px;
    display: flex;
    flex-direction: column;
}

.taskContainer a{
    text-decoration: none;
    color: #0f0f0f;
}

.taskContainer h1{
    text-align: center;
    font-size: 32px;
    margin-bottom: 14px;
}

.task{
    margin-bottom: 14px;
    line-height: 150%; /*para facilitar a leitura*/
    display: flex;
    flex-direction: column;
    align-items: flex-start;/*Vai alinhar à Direita*/
    border: 1.5px solid #909090;
    border-radius: 5px;
    padding: 15px;
}

.tagContainer{
    display: flex;
    align-items: center; /*Vai alinhar altura com relação ao outro, centro horizontal*/
    justify-content: center;
    margin-bottom: 8px;
}

.tag{
    background-color: #3183ff;
    padding: 2px 6px;
    color: #fff;
    border-radius: 5px;
    font-size: 12px;
}

.shareButton, .trashButton{
    background: transparent;
    border: 0;
    margin: 0 8px;
    cursor: pointer;
}

.taskContent{
    display: flex;
    align-items: center;
    justify-content: space-between;
    width: 100%;
}

.taskContent p{
    white-space: pre-wrap; /*Vai respeitar as quebras de linhas, novos paragrafos sem junta-los*/
}




#########################################################

Criar as funcionalidades do projeto com banco de dados.

#########################################################

pages/dashboard/index.tsx:



/* Lembrando que sempre que for PÁGINA tem que que usar DEFAULT */

import styles from './styles.module.css';
import Head from 'next/head';
import { GetServerSideProps } from 'next';
import { getSession } from 'next-auth/react';

//criar a parte de listas
import { FiShare2 } from 'react-icons/fi';
import { FaTrash } from 'react-icons/fa';

//visualizar as alterações no painel
import { Textarea } from '@/components/textarea';

//funcionalidades do projeto com banco de dados
import { ChangeEvent, useState } from 'react';


export default function Dashboard(){
    
    //funcionalidades do projeto com banco de dados. Passar isso no textarea
    const [input, setInput] = useState('');
    const [publicTask, setPublicTask]=useState(false); //a caixa de seleção para tornar público inicia sempre como false


//funcionalidades do projeto com banco de dados. Passar a tipagem
    function handleChangePublic(event: ChangeEvent<HTMLInputElement>){
        //console.log(event.target.checked)

        //Se clicar na caixa passar para true
        setPublicTask(event.target.checked)
    }


    return(
        <div className={styles.container}>
            <Head>
                <title>Painel de tarefas</title>
            </Head>  

            {/* visualizar as alterações no painel */}
            <main className={styles.main}>
                <section className={styles.content}>
                    <div className={styles.contentForm}>
                        <h1 className={styles.title}>Qual sua tarefa?</h1>
                        <form> {/*Criado o components/textarea para aproveitar esse formulários e trocar apenas o conteúdo textarea dele  */}
                            
                    {/*//funcionalidades do projeto com banco de dados */}
                            <Textarea
                                placeholder='Digite sua tarefa...'  
                                value={input}  
                                onChange={ (event: ChangeEvent<HTMLTextAreaElement>) => setInput(event.target.value)}                        
                            />  {/* Essa parte:
                            onChange={ (event) => setInput(event.target.value)}  
                            vai dar erro no value. Não vai encontrar. Para corrigir isso deve informar 
                             que ele é do textarea tipando o "event" com impotação de 'ChangeEvent'
                             e dizer a qual elemento pertence, 'HTMLTextAreaElement'.
                             */}


                    {/*//funcionalidades do projeto com banco de dados */}
                            <div className={styles.checkboxArea}> 
                                <input type="checkbox"
                                    className={styles.checkbox} 
                                    checked={publicTask}
                                    onChange={handleChangePublic}
                                />{/*   Iniciar a caixa como true, MAS se fizer assim:
                                checked={true} vai ficar marcada de forma permanente. 
                                Corrigir com useState
                                */}{/*
                                        onChange={} foi iniciada diferente para aprendizado.
                                        Utilizada uma função externa.
                                */}


                                <label>Deixar tarefa publica?</label>
                            </div>
                            <button type='submit' className={styles.button}>
                                Registrar
                            </button>
                        </form>
                    </div>
                </section>  

                {/*criar a parte de listas */}
                <section className={styles.taskContainer}>
                    <h1>Minhas tarefas</h1>

                    <article className={styles.task}>
                        <div className={styles.tagContainer}>
                            <label className={styles.tag}>PÚBLICO</label>
                            <button className={styles.shareButton}>
                                <FiShare2
                                    size={22}
                                    color="#3183ff"

                                />
                            </button>
                        </div>

                        <div className={styles.taskContent}>
                            <p>Minha primeira tarefa</p>
                            <button className={styles.trashButton}>
                                <FaTrash size={22}
                                color='#ea3140'/>
                            </button>
                        </div>
                    </article>
                </section>

            </main>  

        </div>
    )
}

//proteger o link /dashboard no navegador. Server Side é sempre executado no lado do SERVIDOR.

export const getServerSideProps: GetServerSideProps =async ( {req} ) => {//Escreva ""req"" de requisição. Importante ser apenas essas 3 letras
    //console.log("Buscando pelo server side"); //Veja no   TERMINAL
    //importar getSession para não ter que usar useEffect
    const session = await getSession( {req} );
    //console.log(session); //Veja no   TERMINAL
    if( !session?.user ){
        //Se não tem user, vá para home
        return{
            redirect: {
                destination: '/', //Home
                permanent: false
            },
        };

    }

    return{
        props:{},
    }
}


$$$$$$$$$$$$$$$$$

O BD escolhido é o Firebase certifique-se que esteja instalado

yarn add firebase



$$$$$$$$$$$$$$$$$  Registrar no FireBase

https://firebase.google.com/?hl=pt

Ir para o console / + Adicionar Projeto / 
nextprojecttarefa
* Ativar( o Goole Analytics neste Projeto ) isso é gratuito

ao finalizar ir em icone 'web' </>
Registrar app: Next Project Tarefas
Desmarcar: Configure também o Firebase Hosting para este app.

Registrar App

---------------------Dados fictícios:

// Import the functions you need from the SDKs you need
import { initializeApp } from "firebase/app";
import { getAnalytics } from "firebase/analytics";
// TODO: Add SDKs for Firebase products that you want to use
// https://firebase.google.com/docs/web/setup#available-libraries

// Your web app's Firebase configuration
// For Firebase JS SDK v7.20.0 and later, measurementId is optional
const firebaseConfig = {
  apiKey: "AIzaSyAo_7KJMydasdas5464gbRdasda_1EeU",
  authDomain: "nextprojecttarefa.firebaseapp.com",
  projectId: "nextvdsvsdvsrefa",
  storageBucket: "nextdvsvsdvsdfa.appspot.com",
  messagingSenderId: "263456363904",
  appId: "1:23316782904:web:b1a9b53453b657587hfgchbcvb032b6bcd",
  measurementId: "G-GWRGERGERGR"
};

// Initialize Firebase
const app = initializeApp(firebaseConfig);
const analytics = getAnalytics(app);


-------------Inicializar  Firestore :

Criação (build) / Firestore Database / Criar banco de dados
(V) Iniciar no modo de teste
southamerica-east1 (São Paulo)

--Em regras ajustar mais tempo:
 allow read, write: if
          request.time < timestamp.date(2030, 4, 17);
    }



------------em src/services/firebaseConnection.ts  Somente:( ts ) 



import { initializeApp } from "firebase/app";
import { getAnalytics } from "firebase/analytics";

//Importar também getFirestore que é o BD escolhido
import { getFirestore } from 'firebase/firestore'

const firebaseConfig = {
	 ...
	...
};

// Initialize Firebase. Trocar a variável padrão 'app' por firebaseApp. Fica melhor.
//No caso aqui estou usando também o analytics ( const analytics = getAnalytics(app); ) vou trocar por 'db'
const app = initializeApp(firebaseConfig);
//const analytics = getAnalytics(app);
const db = getFirestore(app);

export { db };



--------------------

--------------------Ajustar db no projeto. Em pages/dashboard/index.tsx.
Na parte do formulário acrescentar onSubmit{} com uma função:





/* Lembrando que sempre que for PÁGINA tem que que usar DEFAULT */

import styles from './styles.module.css';
import Head from 'next/head';
import { GetServerSideProps } from 'next';
import { getSession } from 'next-auth/react';

//criar a parte de listas
import { FiShare2 } from 'react-icons/fi';
import { FaTrash } from 'react-icons/fa';

//visualizar as alterações no painel
import { Textarea } from '@/components/textarea';

//funcionalidades do projeto com banco de dados
import { ChangeEvent, FormEvent, useState } from 'react';


export default function Dashboard(){
    
    //funcionalidades do projeto com banco de dados. Passar isso no textarea
    const [input, setInput] = useState('');
    const [publicTask, setPublicTask]=useState(false); //a caixa de seleção para tornar público inicia sempre como false


//funcionalidades do projeto com banco de dados. Passar a tipagem
    function handleChangePublic(event: ChangeEvent<HTMLInputElement>){
        //console.log(event.target.checked)

        //Se clicar na caixa passar para true
        setPublicTask(event.target.checked)
    }


//Ajustar db no projeto. Tem que tipar o evento importando FormEvent
   function handleRegisterTask(event: FormEvent){
    event.preventDefault();      // Para não atualizar a página. Em typeScript fica dessa forma.

    //Se o input for vazio, não digitou nada. Não deixar enviar vazio para DB.
    if(input === '') return;
    alert('teste')

   }



    return(
        <div className={styles.container}>
            <Head>
                <title>Painel de tarefas</title>
            </Head>  

            {/* visualizar as alterações no painel */}
            <main className={styles.main}>
                <section className={styles.content}>
                    <div className={styles.contentForm}>
                        <h1 className={styles.title}>Qual sua tarefa?</h1>

                        {/**Ajustar db no projeto usando onSubmit{} nos formularios */}
                        <form onSubmit={handleRegisterTask}> {/*Criado o components/textarea para aproveitar esse formulários e trocar apenas o conteúdo textarea dele  */}
                            
                    {/*//funcionalidades do projeto com banco de dados */}
                            <Textarea
                                placeholder='Digite sua tarefa...'  
                                value={input}  
                                onChange={ (event: ChangeEvent<HTMLTextAreaElement>) => setInput(event.target.value)}                        
                            />  {/* Essa parte:
                            onChange={ (event) => setInput(event.target.value)}  
                            vai dar erro no value. Não vai encontrar. Para corrigir isso deve informar 
                             que ele é do textarea tipando o "event" com impotação de 'ChangeEvent'
                             e dizer a qual elemento pertence, 'HTMLTextAreaElement'.
                             */}


                    {/*//funcionalidades do projeto com banco de dados */}
                            <div className={styles.checkboxArea}> 
                                <input type="checkbox"
                                    className={styles.checkbox} 
                                    checked={publicTask}
                                    onChange={handleChangePublic}
                                />{/*   Iniciar a caixa como true, MAS se fizer assim:
                                checked={true} vai ficar marcada de forma permanente. 
                                Corrigir com useState
                                */}{/*
                                        onChange={} foi iniciada diferente para aprendizado.
                                        Utilizada uma função externa.
                                */}


                                <label>Deixar tarefa publica?</label>
                            </div>
                            <button type='submit' className={styles.button}>
                                Registrar
                            </button>
                        </form>
                    </div>
                </section>  

                {/*criar a parte de listas */}
                <section className={styles.taskContainer}>
                    <h1>Minhas tarefas</h1>

                    <article className={styles.task}>
                        <div className={styles.tagContainer}>
                            <label className={styles.tag}>PÚBLICO</label>
                            <button className={styles.shareButton}>
                                <FiShare2
                                    size={22}
                                    color="#3183ff"

                                />
                            </button>
                        </div>

                        <div className={styles.taskContent}>
                            <p>Minha primeira tarefa</p>
                            <button className={styles.trashButton}>
                                <FaTrash size={22}
                                color='#ea3140'/>
                            </button>
                        </div>
                    </article>
                </section>

            </main>  

        </div>
    )
}

//proteger o link /dashboard no navegador. Server Side é sempre executado no lado do SERVIDOR.

export const getServerSideProps: GetServerSideProps =async ( {req} ) => {//Escreva ""req"" de requisição. Importante ser apenas essas 3 letras
    //console.log("Buscando pelo server side"); //Veja no   TERMINAL
    //importar getSession para não ter que usar useEffect
    const session = await getSession( {req} );
    //console.log(session); //Veja no   TERMINAL
    if( !session?.user ){
        //Se não tem user, vá para home
        return{
            redirect: {
                destination: '/', //Home
                permanent: false
            },
        };

    }

    return{
        props:{},
    }
}



--------------------------Finalmente registrar no BD as tarefas !!!

Em pages/dashboard/index.tsx importar db e addDoc, Collection





/* Lembrando que sempre que for PÁGINA tem que que usar DEFAULT */

import styles from './styles.module.css';
import Head from 'next/head';
import { GetServerSideProps } from 'next';
import { getSession } from 'next-auth/react';

//criar a parte de listas
import { FiShare2 } from 'react-icons/fi';
import { FaTrash } from 'react-icons/fa';

//visualizar as alterações no painel
import { Textarea } from '@/components/textarea';

//funcionalidades do projeto com banco de dados
import { ChangeEvent, FormEvent, useState } from 'react';

//registrar no BD as tarefas
import { db } from '../../services/firebaseConnection';
import { addDoc, collection } from 'firebase/firestore';


//registrar no BD as tarefas. HomeProps dizer o que tem dentro de {user} e o tipo
interface HomeProps{
    user:{
        email: string
    }
}


//registrar no BD as tarefas. Vai dar erro no {user}, precisa fazer a tipagem do typesript 
export default function Dashboard( {user}: HomeProps ){
    
    //funcionalidades do projeto com banco de dados. Passar isso no textarea
    const [input, setInput] = useState('');
    const [publicTask, setPublicTask]=useState(false); //a caixa de seleção para tornar público inicia sempre como false


//funcionalidades do projeto com banco de dados. Passar a tipagem
    function handleChangePublic(event: ChangeEvent<HTMLInputElement>){
        //console.log(event.target.checked)

        //Se clicar na caixa passar para true
        setPublicTask(event.target.checked)
    }


//Ajustar db no projeto. Tem que tipar o evento importando FormEvent
//registrar no BD as tarefas. Passar para assincrona - async
   async function handleRegisterTask(event: FormEvent){
    event.preventDefault();      // Para não atualizar a página. Em typeScript fica dessa forma.

    //Se o input for vazio, não digitou nada. Não deixar enviar vazio para DB.
    if(input === '') return;
    //alert('teste')

    //registrar no BD as tarefas
    //addDoc para criar um id aleatório e passar o nome da collection que será criada no db
    try{
        await addDoc(collection(db, "nexttask"),{
            tarefa: input,
            created: new Date(),
            user: user?.email,
            public: publicTask
        });
        setInput(''); //Para voltar vazio
        setPublicTask(false); //Voltar para false para próxima tarefa
        alert('Tarefa salva no BD')
    }catch(err){
        console.log('Erro:', err);
        alert('Erro em registrar as tarefas no BD .')

    }

    /*
    tarefa: input,          -Recebe o que digitar no input
    created: new Date(),    -Data atual do registro
    user: user?.email,      -Se usuário logado
    public: publicTask      -Se a tarefa é publica ou não
    
    *** Veja lá no final do cod o retun
    */

   }



    return(
        <div className={styles.container}>
            <Head>
                <title>Painel de tarefas</title>
            </Head>  

            {/* visualizar as alterações no painel */}
            <main className={styles.main}>
                <section className={styles.content}>
                    <div className={styles.contentForm}>
                        <h1 className={styles.title}>Qual sua tarefa?</h1>

                        {/**Ajustar db no projeto usando onSubmit{} nos formularios */}
                        <form onSubmit={handleRegisterTask}> {/*Criado o components/textarea para aproveitar esse formulários e trocar apenas o conteúdo textarea dele  */}
                            
                    {/*//funcionalidades do projeto com banco de dados */}
                            <Textarea
                                placeholder='Digite sua tarefa...'  
                                value={input}  
                                onChange={ (event: ChangeEvent<HTMLTextAreaElement>) => setInput(event.target.value)}                        
                            />  {/* Essa parte:
                            onChange={ (event) => setInput(event.target.value)}  
                            vai dar erro no value. Não vai encontrar. Para corrigir isso deve informar 
                             que ele é do textarea tipando o "event" com impotação de 'ChangeEvent'
                             e dizer a qual elemento pertence, 'HTMLTextAreaElement'.
                             */}


                    {/*//funcionalidades do projeto com banco de dados */}
                            <div className={styles.checkboxArea}> 
                                <input type="checkbox"
                                    className={styles.checkbox} 
                                    checked={publicTask}
                                    onChange={handleChangePublic}
                                />{/*   Iniciar a caixa como true, MAS se fizer assim:
                                checked={true} vai ficar marcada de forma permanente. 
                                Corrigir com useState
                                */}{/*
                                        onChange={} foi iniciada diferente para aprendizado.
                                        Utilizada uma função externa.
                                */}


                                <label>Deixar tarefa publica?</label>
                            </div>
                            <button type='submit' className={styles.button}>
                                Registrar
                            </button>
                        </form>
                    </div>
                </section>  

                {/*criar a parte de listas */}
                <section className={styles.taskContainer}>
                    <h1>Minhas tarefas</h1>

                    <article className={styles.task}>
                        <div className={styles.tagContainer}>
                            <label className={styles.tag}>PÚBLICO</label>
                            <button className={styles.shareButton}>
                                <FiShare2
                                    size={22}
                                    color="#3183ff"

                                />
                            </button>
                        </div>

                        <div className={styles.taskContent}>
                            <p>Minha primeira tarefa</p>
                            <button className={styles.trashButton}>
                                <FaTrash size={22}
                                color='#ea3140'/>
                            </button>
                        </div>
                    </article>
                </section>

            </main>  

        </div>
    )
}

//proteger o link /dashboard no navegador. Server Side é sempre executado no lado do SERVIDOR.

//Get server side props para fazer a verificação se tem usuário logado
export const getServerSideProps: GetServerSideProps =async ( {req} ) => {//Escreva ""req"" de requisição. Importante ser apenas essas 3 letras
    //console.log("Buscando pelo server side"); //Veja no   TERMINAL
    //importar getSession para não ter que usar useEffect
    const session = await getSession( {req} );
    //console.log(session); //Veja no   TERMINAL
    if( !session?.user ){
        //Se não tem user, vá para home
        return{
            redirect: {
                destination: '/', //Home
                permanent: false
            },
        };

    }

    //registrar no BD as tarefas. Precisa retornar uma propriedade para o componente props
    //email: session?.user?.email agora a função Dashboard() pode receber essa propriedade "user"
    return{
        props:{
            user:{
                email: session?.user?.email
            }
        },
    }
}


***************************************

TESTAR COM LOGIN DE USUÁRIOS DIFERENTES

http://localhost:3000/dashboard
https://console.firebase.google.com/project/nextprojecttarefa/firestore/data/~2Fnexttask~2FpiDE4uY984aYzt7tL7hq?hl=pt

***************************************

Para listar itens tem 2 formas de se fazer. 


1) Buscar informações do server side e passar como propriedade aqui:

return{
        props:{
            user:{
                email: session?.user?.email
            }
        },
    }
}


-----
2) Para usar a função de REALTIME será melhor buscar dentro do useEffect.
Importar useEffect; 
query, 		
orderBy,	para ordenar
where,		para fazer um filtro
onSnapshot, 	para real time







/* Lembrando que sempre que for PÁGINA tem que que usar DEFAULT */

import styles from './styles.module.css';
import Head from 'next/head';
import { GetServerSideProps } from 'next';
import { getSession } from 'next-auth/react';

//criar a parte de listas
import { FiShare2 } from 'react-icons/fi';
import { FaTrash } from 'react-icons/fa';

//visualizar as alterações no painel
import { Textarea } from '@/components/textarea';

//funcionalidades do projeto com banco de dados
import { ChangeEvent, FormEvent, useState, useEffect } from 'react';

//registrar no BD as tarefas
import { db } from '../../services/firebaseConnection';
import { addDoc, collection, query, orderBy, where, onSnapshot } from 'firebase/firestore';


//registrar no BD as tarefas. HomeProps dizer o que tem dentro de {user} e o tipo
interface HomeProps{
    user:{
        email: string
    }
}


//listar itens para função de REALTIME. Por estar usando TypeScript pode criar um array com objetos
interface TasckProps{
    id: string;
    created: Date;
    public: boolean;
    tarefa: string;
    user: string;
}

//registrar no BD as tarefas. Vai dar erro no {user}, precisa fazer a tipagem do typesript 
export default function Dashboard( {user}: HomeProps ){
    
    //funcionalidades do projeto com banco de dados. Passar isso no textarea
    const [input, setInput] = useState('');
    const [publicTask, setPublicTask]=useState(false); //a caixa de seleção para tornar público inicia sempre como false

    //listar itens para função de REALTIME. Usar typescript, vai ficar melhor para criar um array com objetos
    //const [task, setTask] = useState([]);
    const [task, setTask] = useState<TasckProps[]>([]);


//listar itens para função de REALTIME
    useEffect(()=>{ 
        async function loadTarefas(){
            //Buscar no bd a coleção que quer acessar
            const tarefasRef = collection(db, "nexttask" )
            //Criar filtro para ordenar por ordem de criação e exibir SOMENTE conteúdo do user logado com where('user', '==', user?.email) 
            const q = query(
                tarefasRef,
                orderBy("created", "desc"),
                where('user', '==', user?.email)

            )
            //Agora pode buscar usando realtime passando a referência query para receber o retorno"CallBack" com snapshot para ter acesso a todos os dados do user
           
            onSnapshot(q, (snapshot)=>{ //http://localhost:3000/dashboard   Dar um F5

                //console.log(snapshot);// Vai reclamar que "where" precisa de index. Veja anotações na documentação própria deste projeto.
/*Na lista em inspecionar/console veja que agora tem acesso a todos os dados que podem ser usados no projeto */
                //alert("snapshot foi lido")

                //Agora que está tudo ok, precisa criar um local para armazenar usando typescript
                let lista = [] as TasckProps[];
                //Agora pode percorrrer todos os elementos que achou em snapshot com NOMES EXATAMENTE IGUAIS AO CRIADOS NO DB
                snapshot.forEach( (doc)=>{
                    lista.push( {    //Só vai conseguir passar aqui o que foi chamado na tipagem
                        id: doc.id,
                        tarefa: doc.data().tarefa,
                        created: doc.data().created,
                        user: doc.data().user,
                        public: doc.data().public
                     })
                })
                //console.log(lista)
                //alert('lista carregada no console')

                //Testado. Passar para useState
                setTask(lista);

                //Pronto. Agora pode char isso lá no article para exibir todos os itens na página


            })
        }//Lembrar sempre de CHAMAR A FUNÇÃO

        loadTarefas();

    },[user?.email]) //Por estar usando algo externo passar user?.email como DEPENDÊNCIA.

//funcionalidades do projeto com banco de dados. Passar a tipagem
    function handleChangePublic(event: ChangeEvent<HTMLInputElement>){
        //console.log(event.target.checked)

        //Se clicar na caixa passar para true
        setPublicTask(event.target.checked)
    }


//Ajustar db no projeto. Tem que tipar o evento importando FormEvent
//registrar no BD as tarefas. Passar para assincrona - async
   async function handleRegisterTask(event: FormEvent){
    event.preventDefault();      // Para não atualizar a página. Em typeScript fica dessa forma.

    //Se o input for vazio, não digitou nada. Não deixar enviar vazio para DB.
    if(input === '') return;
    //alert('teste')

    //registrar no BD as tarefas
    //addDoc para criar um id aleatório e passar o nome da collection que será criada no db
    try{
        await addDoc(collection(db, "nexttask"),{
            tarefa: input,
            created: new Date(),
            user: user?.email,
            public: publicTask
        });
        setInput(''); //Para voltar vazio
        setPublicTask(false); //Voltar para false para próxima tarefa
        alert('Tarefa salva no BD')
    }catch(err){
        console.log('Erro:', err);
        alert('Erro em registrar as tarefas no BD .')

    }

    /*
    tarefa: input,          -Recebe o que digitar no input
    created: new Date(),    -Data atual do registro
    user: user?.email,      -Se usuário logado
    public: publicTask      -Se a tarefa é publica ou não
    
    *** Veja lá no final do cod o retun
    */

   }



    return(
        <div className={styles.container}>
            <Head>
                <title>Painel de tarefas</title>
            </Head>  

            {/* visualizar as alterações no painel */}
            <main className={styles.main}>
                <section className={styles.content}>
                    <div className={styles.contentForm}>
                        <h1 className={styles.title}>Qual sua tarefa?</h1>

                        {/**Ajustar db no projeto usando onSubmit{} nos formularios */}
                        <form onSubmit={handleRegisterTask}> {/*Criado o components/textarea para aproveitar esse formulários e trocar apenas o conteúdo textarea dele  */}
                            
                    {/*//funcionalidades do projeto com banco de dados */}
                            <Textarea
                                placeholder='Digite sua tarefa...'  
                                value={input}  
                                onChange={ (event: ChangeEvent<HTMLTextAreaElement>) => setInput(event.target.value)}                        
                            />  {/* Essa parte:
                            onChange={ (event) => setInput(event.target.value)}  
                            vai dar erro no value. Não vai encontrar. Para corrigir isso deve informar 
                             que ele é do textarea tipando o "event" com impotação de 'ChangeEvent'
                             e dizer a qual elemento pertence, 'HTMLTextAreaElement'.
                             */}


                    {/*//funcionalidades do projeto com banco de dados */}
                            <div className={styles.checkboxArea}> 
                                <input type="checkbox"
                                    className={styles.checkbox} 
                                    checked={publicTask}
                                    onChange={handleChangePublic}
                                />{/*   Iniciar a caixa como true, MAS se fizer assim:
                                checked={true} vai ficar marcada de forma permanente. 
                                Corrigir com useState
                                */}{/*
                                        onChange={} foi iniciada diferente para aprendizado.
                                        Utilizada uma função externa.
                                */}


                                <label>Deixar tarefa publica?</label>
                            </div>
                            <button type='submit' className={styles.button}>
                                Registrar
                            </button>
                        </form>
                    </div>
                </section>  

                {/*criar a parte de listas */}
                <section className={styles.taskContainer}>
                    <h1>Minhas tarefas</h1>

{/**listar itens para função de REALTIME. Lembrar de por uma key obrigatória*/}

                    {task.map((item)=>(

                    <article key={item.id}     className={styles.task}>

                       {/*Só exibir botão "PÚBLICO"  se estiver público o conteúdo*/} 
                       {item.public && (

                            <div className={styles.tagContainer}>
                                <label className={styles.tag}>PÚBLICO</label>
                                <button className={styles.shareButton}>
                                <FiShare2
                                    size={22}
                                    color="#3183ff"

                                />
                                 </button>
                            </div>

                       )}
                        

                        <div className={styles.taskContent}>

         {/*listar itens para função de REALTIME. Agora pode corrigir o parágrafo
           <p>Minha primeira tarefa</p>
         */}                   
                            <p>{item.tarefa}</p>
                            <button className={styles.trashButton}>
                                <FaTrash size={22}
                                color='#ea3140'/>
                            </button>
                        </div>
                    </article>

                    ))}


                    
                </section>

            </main>  

        </div>
    )
}

//proteger o link /dashboard no navegador. Server Side é sempre executado no lado do SERVIDOR.

//Get server side props para fazer a verificação se tem usuário logado
export const getServerSideProps: GetServerSideProps =async ( {req} ) => {//Escreva ""req"" de requisição. Importante ser apenas essas 3 letras
    //console.log("Buscando pelo server side"); //Veja no   TERMINAL
    //importar getSession para não ter que usar useEffect
    const session = await getSession( {req} );
    //console.log(session); //Veja no   TERMINAL
    if( !session?.user ){
        //Se não tem user, vá para home
        return{
            redirect: {
                destination: '/', //Home
                permanent: false
            },
        };

    }

    //registrar no BD as tarefas. Precisa retornar uma propriedade para o componente props
    //email: session?.user?.email agora a função Dashboard() pode receber essa propriedade "user"
    return{
        props:{
            user:{
                email: session?.user?.email
            }
        },
    }
}










----------------
onSnapshot(q, (snapshot)=>{
                console.log(snapshot);

// Vai reclamar que "where" precisa de index.  http://localhost:3000/dashboard
            
PARA CORRIGIR ISSO vá em 

https://console.firebase.google.com/project/nextprojecttarefa/firestore/indexes?hl=pt-br

Na aba Índices / Criar índices

Collections ID (Código do conjunto) - passar o nome da collection em uso
nexttask
--
Campos para indexar
No mínimo dois campos obrigatórios*
user		Ascending
created		Descending

--
Escopos da consulta
Coleção

--
Criar índice



-----
*****Criar outro invertido 

Código do conjunto
nexttask

Campos para indexar
No mínimo dois campos obrigatórios*
user		Descending
created		Ascending

Escopos da consulta
Coleção
Para consultas dentro de um caminho de coleção específico

--
Criar índice

----------------Vai demorar um pouco para criar------------------

Se atualizar a página do projeto em inspecionar vai ver que a mensagem de reclamação do where foi corrigida

http://localhost:3000/dashboard   F5 para atualizar e veja o que pode ser usado no projeto lá em inspecionar/console
referente aos dados que já foram armazenados anteriormente para teste



-----------------------------------
Criar link para tarefa pública e funcionalidade de COPIAR para shareButton onClick={ ()=> handleShare(item.id)}:




/* Lembrando que sempre que for PÁGINA tem que que usar DEFAULT */

import styles from './styles.module.css';
import Head from 'next/head';
import { GetServerSideProps } from 'next';
import { getSession } from 'next-auth/react';

//criar a parte de listas
import { FiShare2 } from 'react-icons/fi';
import { FaTrash } from 'react-icons/fa';

//visualizar as alterações no painel
import { Textarea } from '@/components/textarea';

//funcionalidades do projeto com banco de dados
import { ChangeEvent, FormEvent, useState, useEffect } from 'react';

//registrar no BD as tarefas
import { db } from '../../services/firebaseConnection';
import { addDoc, collection, query, orderBy, where, onSnapshot } from 'firebase/firestore';


//Link tarefa pública
import Link from 'next/link';

//registrar no BD as tarefas. HomeProps dizer o que tem dentro de {user} e o tipo
interface HomeProps{
    user:{
        email: string
    }
}


//listar itens para função de REALTIME. Por estar usando TypeScript pode criar um array com objetos
interface TasckProps{
    id: string;
    created: Date;
    public: boolean;
    tarefa: string;
    user: string;
}

//registrar no BD as tarefas. Vai dar erro no {user}, precisa fazer a tipagem do typesript 
export default function Dashboard( {user}: HomeProps ){
    
    //funcionalidades do projeto com banco de dados. Passar isso no textarea
    const [input, setInput] = useState('');
    const [publicTask, setPublicTask]=useState(false); //a caixa de seleção para tornar público inicia sempre como false

    //listar itens para função de REALTIME. Usar typescript, vai ficar melhor para criar um array com objetos
    //const [task, setTask] = useState([]);
    const [task, setTask] = useState<TasckProps[]>([]);


//listar itens para função de REALTIME
    useEffect(()=>{ 
        async function loadTarefas(){
            //Buscar no bd a coleção que quer acessar
            const tarefasRef = collection(db, "nexttask" )
            //Criar filtro para ordenar por ordem de criação e exibir SOMENTE conteúdo do user logado com where('user', '==', user?.email) 
            const q = query(
                tarefasRef,
                orderBy("created", "desc"),
                where('user', '==', user?.email)

            )
            //Agora pode buscar usando realtime passando a referência query para receber o retorno"CallBack" com snapshot para ter acesso a todos os dados do user
           
            onSnapshot(q, (snapshot)=>{ //http://localhost:3000/dashboard   Dar um F5

                //console.log(snapshot);// Vai reclamar que "where" precisa de index. Veja anotações na documentação própria deste projeto.
/*Na lista em inspecionar/console veja que agora tem acesso a todos os dados que podem ser usados no projeto */
                //alert("snapshot foi lido")

                //Agora que está tudo ok, precisa criar um local para armazenar usando typescript
                let lista = [] as TasckProps[];
                //Agora pode percorrrer todos os elementos que achou em snapshot com NOMES EXATAMENTE IGUAIS AO CRIADOS NO DB
                snapshot.forEach( (doc)=>{
                    lista.push( {    //Só vai conseguir passar aqui o que foi chamado na tipagem
                        id: doc.id,
                        tarefa: doc.data().tarefa,
                        created: doc.data().created,
                        user: doc.data().user,
                        public: doc.data().public
                     })
                })
                //console.log(lista)
                //alert('lista carregada no console')

                //Testado. Passar para useState
                setTask(lista);

                //Pronto. Agora pode char isso lá no article para exibir todos os itens na página


            })
        }//Lembrar sempre de CHAMAR A FUNÇÃO

        loadTarefas();

    },[user?.email]) //Por estar usando algo externo passar user?.email como DEPENDÊNCIA.

//funcionalidades do projeto com banco de dados. Passar a tipagem
    function handleChangePublic(event: ChangeEvent<HTMLInputElement>){
        //console.log(event.target.checked)

        //Se clicar na caixa passar para true
        setPublicTask(event.target.checked)
    }


//Ajustar db no projeto. Tem que tipar o evento importando FormEvent
//registrar no BD as tarefas. Passar para assincrona - async
   async function handleRegisterTask(event: FormEvent){
    event.preventDefault();      // Para não atualizar a página. Em typeScript fica dessa forma.

    //Se o input for vazio, não digitou nada. Não deixar enviar vazio para DB.
    if(input === '') return;
    //alert('teste')

    //registrar no BD as tarefas
    //addDoc para criar um id aleatório e passar o nome da collection que será criada no db
    try{
        await addDoc(collection(db, "nexttask"),{
            tarefa: input,
            created: new Date(),
            user: user?.email,
            public: publicTask
        });
        setInput(''); //Para voltar vazio
        setPublicTask(false); //Voltar para false para próxima tarefa
        alert('Tarefa salva no BD')
    }catch(err){
        console.log('Erro:', err);
        alert('Erro em registrar as tarefas no BD .')

    }

    /*
    tarefa: input,          -Recebe o que digitar no input
    created: new Date(),    -Data atual do registro
    user: user?.email,      -Se usuário logado
    public: publicTask      -Se a tarefa é publica ou não
    
    *** Veja lá no final do cod o retun
    */

   }

//Se estiver pública a postagem. Lembrando que id foi passado como string.
async function handleShare(id: string){
    //console.log("ID do user: ", id);//Clicar no botão do link na página de postagem http://localhost:3000/dashboard 
    //Para dar uma funcionalidade como COPIAR automáticamente o link passar função para async e clipboard para copiar:
    await navigator.clipboard.writeText(
        /* `http://localhost:3000/task/${id}`  // Para não ter que fazer assim e ter que mudar depois, pode usar uma funcionalidade do lado do cliente.
        Vá em    .env      e crie NEXT_PUBLIC_URL=http://localhost:3000    SEM BARRA no final
        */

        `${process.env.NEXT_PUBLIC_URL}/task/${id}` //Parar projeto!! Ctrl+C para carregar novamente .env      


    );  alert("URL do link copiado com sucesso.")
}

    return(
        <div className={styles.container}>
            <Head>
                <title>Painel de tarefas</title>
            </Head>  

            {/* visualizar as alterações no painel */}
            <main className={styles.main}>
                <section className={styles.content}>
                    <div className={styles.contentForm}>
                        <h1 className={styles.title}>Qual sua tarefa?</h1>

                        {/**Ajustar db no projeto usando onSubmit{} nos formularios */}
                        <form onSubmit={handleRegisterTask}> {/*Criado o components/textarea para aproveitar esse formulários e trocar apenas o conteúdo textarea dele  */}
                            
                    {/*//funcionalidades do projeto com banco de dados */}
                            <Textarea
                                placeholder='Digite sua tarefa...'  
                                value={input}  
                                onChange={ (event: ChangeEvent<HTMLTextAreaElement>) => setInput(event.target.value)}                        
                            />  {/* Essa parte:
                            onChange={ (event) => setInput(event.target.value)}  
                            vai dar erro no value. Não vai encontrar. Para corrigir isso deve informar 
                             que ele é do textarea tipando o "event" com impotação de 'ChangeEvent'
                             e dizer a qual elemento pertence, 'HTMLTextAreaElement'.
                             */}


                    {/*//funcionalidades do projeto com banco de dados */}
                            <div className={styles.checkboxArea}> 
                                <input type="checkbox"
                                    className={styles.checkbox} 
                                    checked={publicTask}
                                    onChange={handleChangePublic}
                                />{/*   Iniciar a caixa como true, MAS se fizer assim:
                                checked={true} vai ficar marcada de forma permanente. 
                                Corrigir com useState
                                */}{/*
                                        onChange={} foi iniciada diferente para aprendizado.
                                        Utilizada uma função externa.
                                */}


                                <label>Deixar tarefa publica?</label>
                            </div>
                            <button type='submit' className={styles.button}>
                                Registrar
                            </button>
                        </form>
                    </div>
                </section>  

                {/*criar a parte de listas */}
                <section className={styles.taskContainer}>
                    <h1>Minhas tarefas</h1>

{/**listar itens para função de REALTIME. Lembrar de por uma key obrigatória*/}

                    {task.map((item)=>(

                    <article key={item.id}     className={styles.task}>

                       {/*Só exibir botão "PÚBLICO"  se estiver público o conteúdo*/} 
                       {item.public && (

                            <div className={styles.tagContainer}>
                                <label className={styles.tag}>PÚBLICO</label>
                                <button className={styles.shareButton} onClick={ ()=> handleShare(item.id)}>Copiar link: 
                                <FiShare2
                                    size={22}
                                    color="#3183ff"

                                />
                                 </button>
                            </div>

                       )}
                        

                        <div className={styles.taskContent}>

         {/*listar itens para função de REALTIME. Agora pode corrigir o parágrafo
           <p>Minha primeira tarefa</p>
         */}  
         {/* //Link tarefa pública. vai navegar o usuário*/}       
                        {item.public ? (
                            <Link  href={ `/task/${item.id}` }>
                              <p>{item.tarefa}</p>
                            </Link>
                        ):(                            
                            <p>{item.tarefa}</p>
                        ) }  
                        {/**Se não for pública, deixar somente o parágrafo sem link*/}


                            <button className={styles.trashButton}>
                                <FaTrash size={22}
                                color='#ea3140'/>
                            </button>
                        </div>
                    </article>

                    ))}


                    
                </section>

            </main>  

        </div>
    )
}

//proteger o link /dashboard no navegador. Server Side é sempre executado no lado do SERVIDOR.

//Get server side props para fazer a verificação se tem usuário logado
export const getServerSideProps: GetServerSideProps =async ( {req} ) => {//Escreva ""req"" de requisição. Importante ser apenas essas 3 letras
    //console.log("Buscando pelo server side"); //Veja no   TERMINAL
    //importar getSession para não ter que usar useEffect
    const session = await getSession( {req} );
    //console.log(session); //Veja no   TERMINAL
    if( !session?.user ){
        //Se não tem user, vá para home
        return{
            redirect: {
                destination: '/', //Home
                permanent: false
            },
        };

    }

    //registrar no BD as tarefas. Precisa retornar uma propriedade para o componente props
    //email: session?.user?.email agora a função Dashboard() pode receber essa propriedade "user"
    return{
        props:{
            user:{
                email: session?.user?.email
            }
        },
    }
}




----------- .env:
Acrescentado esse conteúdo, depois para fazer manutenção do site todos as correções ficam em um lugar apenas para não ter que ficar procurando.

# funcionalidade para shareButton 
NEXT_PUBLIC_URL=http://localhost:3000




-----------------------------------
Criar funcionalidade DELETAR tarefa:




/* Lembrando que sempre que for PÁGINA tem que que usar DEFAULT */

import styles from './styles.module.css';
import Head from 'next/head';
import { GetServerSideProps } from 'next';
import { getSession } from 'next-auth/react';

//criar a parte de listas
import { FiShare2 } from 'react-icons/fi';
import { FaTrash } from 'react-icons/fa';

//visualizar as alterações no painel
import { Textarea } from '@/components/textarea';

//funcionalidades do projeto com banco de dados
import { ChangeEvent, FormEvent, useState, useEffect } from 'react';

//registrar no BD as tarefas
import { db } from '../../services/firebaseConnection';
import { addDoc, collection, query, orderBy, where, onSnapshot, doc, deleteDoc } from 'firebase/firestore';


//Link tarefa pública
import Link from 'next/link';

//registrar no BD as tarefas. HomeProps dizer o que tem dentro de {user} e o tipo
interface HomeProps{
    user:{
        email: string
    }
}


//listar itens para função de REALTIME. Por estar usando TypeScript pode criar um array com objetos
interface TasckProps{
    id: string;
    created: Date;
    public: boolean;
    tarefa: string;
    user: string;
}

//registrar no BD as tarefas. Vai dar erro no {user}, precisa fazer a tipagem do typesript 
export default function Dashboard( {user}: HomeProps ){
    
    //funcionalidades do projeto com banco de dados. Passar isso no textarea
    const [input, setInput] = useState('');
    const [publicTask, setPublicTask]=useState(false); //a caixa de seleção para tornar público inicia sempre como false

    //listar itens para função de REALTIME. Usar typescript, vai ficar melhor para criar um array com objetos
    //const [task, setTask] = useState([]);
    const [task, setTask] = useState<TasckProps[]>([]);


//listar itens para função de REALTIME
    useEffect(()=>{ 
        async function loadTarefas(){
            //Buscar no bd a coleção que quer acessar
            const tarefasRef = collection(db, "nexttask" )
            //Criar filtro para ordenar por ordem de criação e exibir SOMENTE conteúdo do user logado com where('user', '==', user?.email) 
            const q = query(
                tarefasRef,
                orderBy("created", "desc"),
                where('user', '==', user?.email)

            )
            //Agora pode buscar usando realtime passando a referência query para receber o retorno"CallBack" com snapshot para ter acesso a todos os dados do user
           
            onSnapshot(q, (snapshot)=>{ //http://localhost:3000/dashboard   Dar um F5

                //console.log(snapshot);// Vai reclamar que "where" precisa de index. Veja anotações na documentação própria deste projeto.
/*Na lista em inspecionar/console veja que agora tem acesso a todos os dados que podem ser usados no projeto */
                //alert("snapshot foi lido")

                //Agora que está tudo ok, precisa criar um local para armazenar usando typescript
                let lista = [] as TasckProps[];
                //Agora pode percorrrer todos os elementos que achou em snapshot com NOMES EXATAMENTE IGUAIS AO CRIADOS NO DB
                snapshot.forEach( (doc)=>{
                    lista.push( {    //Só vai conseguir passar aqui o que foi chamado na tipagem
                        id: doc.id,
                        tarefa: doc.data().tarefa,
                        created: doc.data().created,
                        user: doc.data().user,
                        public: doc.data().public
                     })
                })
                //console.log(lista)
                //alert('lista carregada no console')

                //Testado. Passar para useState
                setTask(lista);

                //Pronto. Agora pode char isso lá no article para exibir todos os itens na página


            })
        }//Lembrar sempre de CHAMAR A FUNÇÃO

        loadTarefas();

    },[user?.email]) //Por estar usando algo externo passar user?.email como DEPENDÊNCIA.

//funcionalidades do projeto com banco de dados. Passar a tipagem
    function handleChangePublic(event: ChangeEvent<HTMLInputElement>){
        //console.log(event.target.checked)

        //Se clicar na caixa passar para true
        setPublicTask(event.target.checked)
    }


//Ajustar db no projeto. Tem que tipar o evento importando FormEvent
//registrar no BD as tarefas. Passar para assincrona - async
   async function handleRegisterTask(event: FormEvent){
    event.preventDefault();      // Para não atualizar a página. Em typeScript fica dessa forma.

    //Se o input for vazio, não digitou nada. Não deixar enviar vazio para DB.
    if(input === '') return;
    //alert('teste')

    //registrar no BD as tarefas
    //addDoc para criar um id aleatório e passar o nome da collection que será criada no db
    try{
        await addDoc(collection(db, "nexttask"),{
            tarefa: input,
            created: new Date(),
            user: user?.email,
            public: publicTask
        });
        setInput(''); //Para voltar vazio
        setPublicTask(false); //Voltar para false para próxima tarefa
        alert('Tarefa salva no BD')
    }catch(err){
        console.log('Erro:', err);
        alert('Erro em registrar as tarefas no BD .')

    }

    /*
    tarefa: input,          -Recebe o que digitar no input
    created: new Date(),    -Data atual do registro
    user: user?.email,      -Se usuário logado
    public: publicTask      -Se a tarefa é publica ou não
    
    *** Veja lá no final do cod o retun
    */

   }

//Se estiver pública a postagem. Lembrando que id foi passado como string.
async function handleShare(id: string){
    //console.log("ID do user: ", id);//Clicar no botão do link na página de postagem http://localhost:3000/dashboard 
    //Para dar uma funcionalidade como COPIAR automáticamente o link passar função para async e clipboard para copiar:
    await navigator.clipboard.writeText(
        /* `http://localhost:3000/task/${id}`  // Para não ter que fazer assim e ter que mudar depois, pode usar uma funcionalidade do lado do cliente.
        Vá em    .env      e crie NEXT_PUBLIC_URL=http://localhost:3000    SEM BARRA no final
        */

        `${process.env.NEXT_PUBLIC_URL}/task/${id}` //Parar projeto!! Ctrl+C para carregar novamente .env      


    );  alert("URL do link copiado com sucesso.")
}


//Criar funcionalidade DELETAR tarefa. Importar doc e deleteDoc
    async function handleDeleteTask(id: string) {
        const docRef = doc(db, "nexttask",  id); //Referência. Agora é só deletar passando a referência:
        await deleteDoc(docRef);// vai deletar a tarefa que passsar com id

    }

    return(
        <div className={styles.container}>
            <Head>
                <title>Painel de tarefas</title>
            </Head>  

            {/* visualizar as alterações no painel */}
            <main className={styles.main}>
                <section className={styles.content}>
                    <div className={styles.contentForm}>
                        <h1 className={styles.title}>Qual sua tarefa?</h1>

                        {/**Ajustar db no projeto usando onSubmit{} nos formularios */}
                        <form onSubmit={handleRegisterTask}> {/*Criado o components/textarea para aproveitar esse formulários e trocar apenas o conteúdo textarea dele  */}
                            
                    {/*//funcionalidades do projeto com banco de dados */}
                            <Textarea
                                placeholder='Digite sua tarefa...'  
                                value={input}  
                                onChange={ (event: ChangeEvent<HTMLTextAreaElement>) => setInput(event.target.value)}                        
                            />  {/* Essa parte:
                            onChange={ (event) => setInput(event.target.value)}  
                            vai dar erro no value. Não vai encontrar. Para corrigir isso deve informar 
                             que ele é do textarea tipando o "event" com impotação de 'ChangeEvent'
                             e dizer a qual elemento pertence, 'HTMLTextAreaElement'.
                             */}


                    {/*//funcionalidades do projeto com banco de dados */}
                            <div className={styles.checkboxArea}> 
                                <input type="checkbox"
                                    className={styles.checkbox} 
                                    checked={publicTask}
                                    onChange={handleChangePublic}
                                />{/*   Iniciar a caixa como true, MAS se fizer assim:
                                checked={true} vai ficar marcada de forma permanente. 
                                Corrigir com useState
                                */}{/*
                                        onChange={} foi iniciada diferente para aprendizado.
                                        Utilizada uma função externa.
                                */}


                                <label>Deixar tarefa publica?</label>
                            </div>
                            <button type='submit' className={styles.button}>
                                Registrar
                            </button>
                        </form>
                    </div>
                </section>  

                {/*criar a parte de listas */}
                <section className={styles.taskContainer}>
                    <h1>Minhas tarefas</h1>

{/**listar itens para função de REALTIME. Lembrar de por uma key obrigatória*/}

                    {task.map((item)=>(

                    <article key={item.id}     className={styles.task}>

                       {/*Só exibir botão "PÚBLICO"  se estiver público o conteúdo*/} 
                       {item.public && (

                            <div className={styles.tagContainer}>
                                <label className={styles.tag}>PÚBLICO</label>
                                <button className={styles.shareButton} onClick={ ()=> handleShare(item.id)}>Copiar link: 
                                <FiShare2
                                    size={22}
                                    color="#3183ff"

                                />
                                 </button>
                            </div>

                       )}
                        

                        <div className={styles.taskContent}>

         {/*listar itens para função de REALTIME. Agora pode corrigir o parágrafo
           <p>Minha primeira tarefa</p>
         */}  
         {/* //Link tarefa pública. vai navegar o usuário*/}       
                        {item.public ? (
                            <Link  href={ `/task/${item.id}` }>
                              <p>{item.tarefa}</p>
                            </Link>
                        ):(                            
                            <p>{item.tarefa}</p>
                        ) }  
                        {/**Se não for pública, deixar somente o parágrafo sem link*/}


                            {/**Criar funcionalidade DELETAR tarefa. Para passar o id:   handleDeleteTask(item.id) */}
                            <button className={styles.trashButton} onClick={ ()=> handleDeleteTask(item.id)}>
                                <FaTrash size={22}
                                color='#ea3140'/>
                            </button>
                        </div>
                    </article>

                    ))}


                    
                </section>

            </main>  

        </div>
    )
}

//proteger o link /dashboard no navegador. Server Side é sempre executado no lado do SERVIDOR.

//Get server side props para fazer a verificação se tem usuário logado
export const getServerSideProps: GetServerSideProps =async ( {req} ) => {//Escreva ""req"" de requisição. Importante ser apenas essas 3 letras
    //console.log("Buscando pelo server side"); //Veja no   TERMINAL
    //importar getSession para não ter que usar useEffect
    const session = await getSession( {req} );
    //console.log(session); //Veja no   TERMINAL
    if( !session?.user ){
        //Se não tem user, vá para home
        return{
            redirect: {
                destination: '/', //Home
                permanent: false
            },
        };

    }

    //registrar no BD as tarefas. Precisa retornar uma propriedade para o componente props
    //email: session?.user?.email agora a função Dashboard() pode receber essa propriedade "user"
    return{
        props:{
            user:{
                email: session?.user?.email
            }
        },
    }
}





*********************************Criar página task, lembrando que ele é um id.
Aqui não precisa usar o useEffect, a informação pode ser trazida do servidor (server side)

Em src/pages/task/[id].tsx  :



import Head from "next/head";
import styles from './styles.module.css';

export default function Task(){
    return(
        <div className={styles.container}>
            <Head>
                <title>Detalhes da tarefa</title>
            </Head>

            <main className={styles.main}>
                <h1>Tarefa</h1>
            </main>
        </div>
    )
}





----------------------Atualizar src/pages/task/[id].tsx  :




import { async } from "@firebase/util";
import { GetServerSideProps } from "next";
import Head from "next/head";
import styles from './styles.module.css';

//Pull dos detalhes da tarefa no servidor
import { db } from "@/services/firebaseConnection";
import { doc, collection, query, where, getDoc } from 'firebase/firestore';


export default function Task(){
    return(
        <div className={styles.container}>
            <Head>
                <title>Detalhes da tarefa</title>
            </Head>

            <main className={styles.main}>
                <h1>Tarefa</h1>
            </main>
        </div>
    )
}

//Aqui não precisa usar o useEffect, a informação pode ser trazida do servidor (server side)
// Os dois pontos é para usar a tipagem do typescript
export const getServerSideProps: GetServerSideProps = async ( {params} )=>{
    // params? com interrogação  caso o usuário tente acessar digitando algo no link
    const idTask = params?.id as string;
    //console.log("Id recebido no [id].tsx: ",id);//Veja no TERMINAL ao atualizar uma página task
    
    //Pull dos detalhes da tarefa no servidor
    const docRef = doc(db, 'nexttask', idTask);
    //Buscar informação do BD
    const snapshot = await getDoc(docRef);

    //Fazer a verificação
    if( snapshot.data() === undefined && !snapshot.data()?.public ){ //Se ele não encontrar tarefa. Caso tente digitar algo que não existe direcionar para home, por isso usar o "permanent: false"
        return{
            redirect: {
                destination: '/',
                permanent: false
            }
        }
    }
//IMPORTANTÍSSIMO
//Outros usuários acessar apenas tarefas PÚBLICAS. "public" foi o nome dado no BD.            
    if( !snapshot.data()?.public ){//Se NÃO for pública:
        return{
            redirect: {
                destination: '/',
                permanent: false
            }
        }
    }
   // console.log(snapshot.data()); //Veja no TERMINAL ao atualizar uma página task

    /*Obviamente que poderia ter sido feito assim:
    if( snapshot.data() === undefined && !snapshot.data()?.public )  
    Foram separados apenas para entendimento*/

//A data está vindo como Timestamp, exemplo, 20032023. Converter created com data formatada, 20/03/2023.
    const miliseconds = snapshot.data()?.created?.seconds * 1000;
    const task = {
        tarefa: snapshot.data()?.tarefa,
        public: snapshot.data()?.public,
        created: new Date( miliseconds ).toLocaleDateString(),
        user: snapshot.data()?.user,
        taskId: idTask
    }
    console.log(task);



    return{
        props: {}
    }
}




----------------------Enviar objetos para a página task.
Atualizar src/pages/task/[id].tsx  :




import { async } from "@firebase/util";
import { GetServerSideProps } from "next";
import Head from "next/head";
import styles from './styles.module.css';

//Pull dos detalhes da tarefa no servidor
import { db } from "@/services/firebaseConnection";
import { doc, collection, query, where, getDoc } from 'firebase/firestore';

//Enviar objetos para a página task. Tipagem para "item"
interface TaskProps{
    item: {//Dentro dele tem as propriedades que foram exibidas no terminal em console.log(task);
        tarefa: string,
        public: boolean,
        created: string,
        user: string,
        taskId: string
    } //Para saber o que cada um é (bool, string) basta olhar no terminal com console.log(task); habilitado
}

//Enviar objetos para a página task. Precisa acrescentar item na função. O typescript quer saber o que tem nele, criar uma tipagem para ele
//export default function Task(  {item}  ){
    
//Passada a tipagem, agora item vai respeitar ela acrescentando TaskProps
export default function Task( {item}:TaskProps ){
    return(
        <div className={styles.container}>
            <Head>
                <title>Detalhes da tarefa</title>
            </Head>

            <main className={styles.main}>
                <h1>Tarefa</h1>

                {/* //Enviar objetos para a página task. */}
                <article className={styles.task}>
                    <p>
                        {item.tarefa}
                    </p>
                </article>

            </main>
        </div>
    )
}

//Aqui não precisa usar o useEffect, a informação pode ser trazida do servidor (server side)
// Os dois pontos é para usar a tipagem do typescript
export const getServerSideProps: GetServerSideProps = async ( {params} )=>{
    // params? com interrogação  caso o usuário tente acessar digitando algo no link
    const idTask = params?.id as string;
    //console.log("Id recebido no [id].tsx: ",id);//Veja no TERMINAL ao atualizar uma página task
    
    //Pull dos detalhes da tarefa no servidor
    const docRef = doc(db, 'nexttask', idTask);
    //Buscar informação do BD
    const snapshot = await getDoc(docRef);

    //Fazer a verificação
    if( snapshot.data() === undefined && !snapshot.data()?.public ){ //Se ele não encontrar tarefa. Caso tente digitar algo que não existe direcionar para home, por isso usar o "permanent: false"
        return{
            redirect: {
                destination: '/',
                permanent: false
            }
        }
    }
//IMPORTANTÍSSIMO
//Outros usuários acessar apenas tarefas PÚBLICAS. "public" foi o nome dado no BD.            
    if( !snapshot.data()?.public ){//Se NÃO for pública:
        return{
            redirect: {
                destination: '/',
                permanent: false
            }
        }
    }
   // console.log(snapshot.data()); //Veja no TERMINAL ao atualizar uma página task

    /*Obviamente que poderia ter sido feito assim:
    if( snapshot.data() === undefined && !snapshot.data()?.public )  
    Foram separados apenas para entendimento*/

//A data está vindo como Timestamp, exemplo, 20032023. Converter created com data formatada, 20/03/2023.
    const miliseconds = snapshot.data()?.created?.seconds * 1000;
    const task = {
        tarefa: snapshot.data()?.tarefa,
        public: snapshot.data()?.public,
        created: new Date( miliseconds ).toLocaleDateString(),
        user: snapshot.data()?.user,
        taskId: idTask
    }
    console.log(task);



    return{
        props: { //Enviar objetos para a página task
            item: task,
        }
    }
}






-------------Estilizar [id].tsx 
Em src/pages/task/tyles.module.css:



.container{
    width: 100%;
    max-width: 1024px;
    margin: 40px auto 0 auto; /* até aqui vai alinhar tudo */
    padding: 0 18px;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center; /* até aqui vai centralizaar tudo na página */
}

.main{
    width: 100%;/* ele está dentro do container de no máximo 1024px */
}

.main h1{
    margin-bottom: 15px;
}

 /* Crie uma tarefa com texto grande  https://www.lipsum.com/
 */

.task{
    border: 1.5px solid #909090;
    padding: 15px;
    line-height: 100%; /* Para distanciar quebra de linha */
    border-radius: 5px;
    display: flex;   
    justify-content: center;
    align-items: center;
}

.task p{
    white-space: pre-wrap; /* Para quebrar de linha */
    width: 100%;
} /* Veja como fico responsivo. Show de bola */



--------------------Criar comentários em task.











import { GetServerSideProps } from "next";
import Head from "next/head";
import styles from './styles.module.css';

//Pull dos detalhes da tarefa no servidor
import { db } from "@/services/firebaseConnection";
import { doc, collection, query, where, getDoc } from 'firebase/firestore';

//CRIAR A PARTE DE COMENTÁRIOS.
import { Textarea } from "@/components/textarea";

//Limitar comentários
import { useState } from 'react';


//Enviar objetos para a página task. Tipagem para "item"
interface TaskProps{
    item: {//Dentro dele tem as propriedades que foram exibidas no terminal em console.log(task);
        tarefa: string,
        public: boolean,
        created: string,
        user: string,
        taskId: string
    } //Para saber o que cada um é (bool, string) basta olhar no terminal com console.log(task); habilitado
}

//Enviar objetos para a página task. Precisa acrescentar item na função. O typescript quer saber o que tem nele, criar uma tipagem para ele
//export default function Task(  {item}  ){
    
//Passada a tipagem, agora item vai respeitar ela acrescentando TaskProps
export default function Task( {item}:TaskProps ){

//Limitar comentários
    const [comment, setComment] = useState('');
    const handleCommentChange = (event: React.ChangeEvent<HTMLTextAreaElement>) => {
        setComment(event.target.value);
      };    
      const count = comment.length;//Até aqui para limitar comentários e adicionar em Textarea: 
      //maxLength={200} 
      //onChange={handleCommentChange}



    return(
        <div className={styles.container}>
            <Head>
                <title>Detalhes da tarefa</title>
            </Head>

            <main className={styles.main}>
                <h1>Tarefa</h1>

                {/* //Enviar objetos para a página task. */}
                <article className={styles.task}>
                    <p>
                        {item.tarefa}
                    </p>
                </article>

             {/* CRIAR A PARTE DE COMENTÁRIOS. Vai ser interessante importar Textarea*/}
             <section className={styles.comentsContainer}>
                <h2>Deixar comentário</h2>
                <form>
                    <Textarea  placeholder="Digite seu comentário..." 
                    maxLength={200} 
                    onChange={handleCommentChange}
                    />
                    <span>{count} / 200 caracteres</span>
                    <button className={styles.button}>Enviar comentário</button>
                </form>
             </section>

            </main>
        </div>
    )
}

//Aqui não precisa usar o useEffect, a informação pode ser trazida do servidor (server side)
// Os dois pontos é para usar a tipagem do typescript
export const getServerSideProps: GetServerSideProps = async ( {params} )=>{
    // params? com interrogação  caso o usuário tente acessar digitando algo no link
    const idTask = params?.id as string;
    //console.log("Id recebido no [id].tsx: ",id);//Veja no TERMINAL ao atualizar uma página task
    
    //Pull dos detalhes da tarefa no servidor
    const docRef = doc(db, 'nexttask', idTask);
    //Buscar informação do BD
    const snapshot = await getDoc(docRef);

    //Fazer a verificação
    if( snapshot.data() === undefined && !snapshot.data()?.public ){ //Se ele não encontrar tarefa. Caso tente digitar algo que não existe direcionar para home, por isso usar o "permanent: false"
        return{
            redirect: {
                destination: '/',
                permanent: false
            }
        }
    }
//IMPORTANTÍSSIMO
//Outros usuários acessar apenas tarefas PÚBLICAS. "public" foi o nome dado no BD.            
    if( !snapshot.data()?.public ){//Se NÃO for pública:
        return{
            redirect: {
                destination: '/',
                permanent: false
            }
        }
    }
   // console.log(snapshot.data()); //Veja no TERMINAL ao atualizar uma página task

    /*Obviamente que poderia ter sido feito assim:
    if( snapshot.data() === undefined && !snapshot.data()?.public )  
    Foram separados apenas para entendimento*/

//A data está vindo como Timestamp, exemplo, 20032023. Converter created com data formatada, 20/03/2023.
    const miliseconds = snapshot.data()?.created?.seconds * 1000;
    const task = {
        tarefa: snapshot.data()?.tarefa,
        public: snapshot.data()?.public,
        created: new Date( miliseconds ).toLocaleDateString(),
        user: snapshot.data()?.user,
        taskId: idTask
    }
    console.log(task);



    return{
        props: { //Enviar objetos para a página task
            item: task,
        }
    }
}











################### Limitar comentários. Código recortado para avaliar.

//Limitar comentários
import { useState } from 'react';



//Define o estado inicial do comentário como uma string vazia
const [comment, setComment] = useState('');

//Função para lidar com a mudança de texto no textarea
const handleCommentChange = (event: React.ChangeEvent<HTMLTextAreaElement>) => {
    //Atualiza o estado do comentário com o novo valor digitado
    setComment(event.target.value);
};

//Conta o número de caracteres atual no comentário
const count = comment.length;
                   
//Renderiza o componente Textarea com as seguintes propriedades
<Textarea
    placeholder="Digite seu comentário..." //Texto de instrução exibido no textarea
    maxLength={200} //Define o limite máximo de caracteres permitidos no textarea
    onChange={handleCommentChange} //Chama a função handleCommentChange sempre que o texto é alterado
/>

//Renderiza um elemento span para exibir o número de caracteres atual e um aviso caso ultrapasse 170 caracteres
<span className={count >= 170 ? styles.warning : ""}>
    {count} / 200 caracteres
</span>

-----CSS:

/*  Limitar comentários ,  rgb(255, 0, 0) é vermelho*/
.warning {
    color: red; 
  }

###################







import { GetServerSideProps } from "next";
import Head from "next/head";
import styles from './styles.module.css';

//Pull dos detalhes da tarefa no servidor
import { db } from "@/services/firebaseConnection";
import { doc, collection, query, where, getDoc } from 'firebase/firestore';

//CRIAR A PARTE DE COMENTÁRIOS.
import { Textarea } from "@/components/textarea";

//Limitar comentários
import { useState } from 'react';


//Enviar objetos para a página task. Tipagem para "item"
interface TaskProps{
    item: {//Dentro dele tem as propriedades que foram exibidas no terminal em console.log(task);
        tarefa: string,
        public: boolean,
        created: string,
        user: string,
        taskId: string
    } //Para saber o que cada um é (bool, string) basta olhar no terminal com console.log(task); habilitado
}

//Enviar objetos para a página task. Precisa acrescentar item na função. O typescript quer saber o que tem nele, criar uma tipagem para ele
//export default function Task(  {item}  ){
    
//Passada a tipagem, agora item vai respeitar ela acrescentando TaskProps
export default function Task( {item}:TaskProps ){

//Limitar comentários
    const [comment, setComment] = useState('');
    const handleCommentChange = (event: React.ChangeEvent<HTMLTextAreaElement>) => {
        setComment(event.target.value);
      };    
      const count = comment.length;//Até aqui para limitar comentários e adicionar em Textarea: 
      //maxLength={200} 
      //onChange={handleCommentChange}



    return(
        <div className={styles.container}>
            <Head>
                <title>Detalhes da tarefa</title>
            </Head>

            <main className={styles.main}>
                <h1>Tarefa</h1>

                {/* //Enviar objetos para a página task. */}
                <article className={styles.task}>
                    <p>
                        {item.tarefa}
                    </p>
                </article>

             {/* CRIAR A PARTE DE COMENTÁRIOS. Vai ser interessante importar Textarea*/}
             <section className={styles.commentsContainer}>
                <h2>Deixar comentário</h2>
                <form>
                    <Textarea
                    placeholder="Digite seu comentário..."
                    maxLength={200}
                    onChange={handleCommentChange}
                    />
                    <span className={count >= 170 ? styles.warning : ""}>
                    {count} / 200 caracteres
                    </span>
                    <button className={styles.button}>Enviar comentário</button>
                </form>
            </section>

            </main>
        </div>
    )
}

//Aqui não precisa usar o useEffect, a informação pode ser trazida do servidor (server side)
// Os dois pontos é para usar a tipagem do typescript
export const getServerSideProps: GetServerSideProps = async ( {params} )=>{
    // params? com interrogação  caso o usuário tente acessar digitando algo no link
    const idTask = params?.id as string;
    //console.log("Id recebido no [id].tsx: ",id);//Veja no TERMINAL ao atualizar uma página task
    
    //Pull dos detalhes da tarefa no servidor
    const docRef = doc(db, 'nexttask', idTask);
    //Buscar informação do BD
    const snapshot = await getDoc(docRef);

    //Fazer a verificação
    if( snapshot.data() === undefined && !snapshot.data()?.public ){ //Se ele não encontrar tarefa. Caso tente digitar algo que não existe direcionar para home, por isso usar o "permanent: false"
        return{
            redirect: {
                destination: '/',
                permanent: false
            }
        }
    }
//IMPORTANTÍSSIMO
//Outros usuários acessar apenas tarefas PÚBLICAS. "public" foi o nome dado no BD.            
    if( !snapshot.data()?.public ){//Se NÃO for pública:
        return{
            redirect: {
                destination: '/',
                permanent: false
            }
        }
    }
   // console.log(snapshot.data()); //Veja no TERMINAL ao atualizar uma página task

    /*Obviamente que poderia ter sido feito assim:
    if( snapshot.data() === undefined && !snapshot.data()?.public )  
    Foram separados apenas para entendimento*/

//A data está vindo como Timestamp, exemplo, 20032023. Converter created com data formatada, 20/03/2023.
    const miliseconds = snapshot.data()?.created?.seconds * 1000;
    const task = {
        tarefa: snapshot.data()?.tarefa,
        public: snapshot.data()?.public,
        created: new Date( miliseconds ).toLocaleDateString(),
        user: snapshot.data()?.user,
        taskId: idTask
    }
    console.log(task);



    return{
        props: { //Enviar objetos para a página task
            item: task,
        }
    }
}



---------------CSS:

.container{
    width: 100%;
    max-width: 1024px;
    margin: 40px auto 0 auto; /* até aqui vai alinhar tudo */
    padding: 0 18px;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center; /* até aqui vai centralizaar tudo na página */
}

.main{
    width: 100%;/* ele está dentro do container de no máximo 1024px */
}

.main h1{
    margin-bottom: 15px;
}

 /* Crie uma tarefa com texto grande  https://www.lipsum.com/
 */

.task{
    border: 1.5px solid #909090;
    padding: 15px;
    line-height: 100%; /* Para distanciar quebra de linha */
    border-radius: 5px;
    display: flex;   
    justify-content: center;
    align-items: center;
}

.task p{
    white-space: pre-wrap; /* Para quebrar de linha */
    width: 100%;
} /* Veja como fico responsivo. Show de bola */

/* Parte dos comentários */
.comentsContainer{
    margin: 18px 0;
    width: 100%;
    max-width: 1024px;
}

.comentsContainer h2{
    margin: 15px 0;
}

.button{
    width: 100%;
    padding: 10px 0;
    border-radius: 5px;
    border: 0;
    color: #fff;
    background-color: #3183ff;
    font-size: 18px;
    cursor: pointer;
}

/*  Limitar comentários */
.warning {
    color: red;
  }




*************Permitir na postagem somente o nome do usuário com cadastro.
Para isso precisa pegar o que se digita no textarea e armazenar no useState.
Precisa importar useState para deixar dinâmico useSession para saber quem está logado. Esses Hooks vão ajudar.

 Usar disabled={true} para testar css e depois substituir o true por disabled={ !session?.user }
no botão permitir somente logados e acertar isso no CSS com tom de cor mais fraco para "desabilitado"

-----[id].tsx

<button className={styles.button}
   disabled={ !session?.user }
   >{ session?.user ? "Enviar comentário" : "Faça login para enviar comentário"}
</button>

-----css:

  .button:disabled {
    cursor: not-allowed;
    background-color: rgba(49, 131, 255, 0.421);
    color: rgba(255, 0, 0, 0.69);
  }

----------Para passar o texto para a variável input para poder colocar o nome do user nas mensagens

POde fazer de 2 formas:

1)
criar: 
const [ input, setInput ] = useState("");

---
Em <Textarea  para pegar o que digita e passar para setInput:
value={input}
onChange={(event: React.ChangeEvent<HTMLTextAreaElement>) => {
        setInput(event.target.value);
      };} 

precisa criar um: 
<form onSubmit={handleComent}>

-----
2) 
Como já tem uma função de fazer a contagem de caracteres em utilização,
pode aproveitar ela para colocar o nome do user nas mensagens pelo setInput

importante lembrar de acrescentar o valor:  <Textarea value={input}

Vai ficar assim:



//passar o texto para a variável input para poder colocar o nome do user nas mensagens
    const [input, setInput] = useState('');   
//Limitar comentários
    const [comment, setComment] = useState('');
    const handleCommentUser = (event: React.ChangeEvent<HTMLTextAreaElement>) => {
        setComment(event.target.value);
        setInput(event.target.value);
      };    
      const count = comment.length;


<form onSubmit={handleComent}>
      <Textarea 

	  value={input}

          placeholder="Digite seu comentário..."
          maxLength={200}
          onChange={handleCommentUser}                    
       />




-----------------Isso acima ( 2 ) + Salvar comentários no BD:




import { GetServerSideProps } from "next";
import Head from "next/head";
import styles from './styles.module.css';

//Pull dos detalhes da tarefa no servidor
import { db } from "@/services/firebaseConnection";
import { doc, collection, query, where, getDoc, addDoc } from 'firebase/firestore';

//CRIAR A PARTE DE COMENTÁRIOS.
import { Textarea } from "@/components/textarea";

//Permitir na postagem somente o nome do usuário com cadastro.
//Limitar comentários
import { ChangeEvent, FormEvent, useState } from 'react';
import { useSession } from "next-auth/react";

//Enviar objetos para a página task. Tipagem para "item"
interface TaskProps{
    item: {//Dentro dele tem as propriedades que foram exibidas no terminal em console.log(task);
        tarefa: string,
        public: boolean,
        created: string,
        user: string,
        taskId: string
    } //Para saber o que cada um é (bool, string) basta olhar no terminal com console.log(task); habilitado
}

//Enviar objetos para a página task. Precisa acrescentar item na função. O typescript quer saber o que tem nele, criar uma tipagem para ele
//export default function Task(  {item}  ){
//Passada a tipagem, agora item vai respeitar ela acrescentando TaskProps
export default function Task( {item}:TaskProps ){


//passar o texto para a variável input para poder colocar o nome do user nas mensagens
    const [input, setInput] = useState('');   

//Limitar comentários
    const [comment, setComment] = useState('');
    
    const handleCommentUser = (event: React.ChangeEvent<HTMLTextAreaElement>) => {
        setComment(event.target.value);
        setInput(event.target.value);
      };    
    const count = comment.length;//Até aqui para limitar comentários e adicionar em Textarea: 
      //maxLength={200} 
      //onChange={handleCommentChange}

//Permitir na postagem somente o nome do usuário com cadastro. Usar disable={true} no botão para permitir somente logados
    const { data: session } = useSession();


//passar o texto para a variável input para poder colocar o nome do user nas mensagens
    async function handleComent( event: FormEvent ){
        event.preventDefault(); //Para não atualizar a página
        //alert('teste: function handleComent()')

        if ( input === "") return; //Não permitir comentários vazios
        if ( !session?.user?.email || !session?.user?.name) return; //Não permitir comentários sem nome ou email

        try {
            const docRef = await addDoc(collection(db, "comments"), { // Vai criar uma nova coleção para salvar comentários no BD com nome de ''comments''
              comment: input,
              created: new Date(),
              user: session?.user?.email,
              name: session?.user?.name,
              taskId: item?.taskId,
            }); //Acima é o cadastro no BD
      
            setInput(""); //Apagar o input após enviar

          } catch (err) {
            console.log(err);
          }

   }


    return(
        <div className={styles.container}>
            <Head>
                <title>Detalhes da tarefa</title>
            </Head>

            <main className={styles.main}>
                <h1>Tarefa</h1>

                {/* //Enviar objetos para a página task. */}
                <article className={styles.task}>
                    <p>
                        {item.tarefa}
                    </p>
                </article>

             {/* CRIAR A PARTE DE COMENTÁRIOS. Vai ser interessante importar Textarea*/}
             <section className={styles.commentsContainer}>
                <h2>Deixar comentário</h2>
                <form onSubmit={handleComent}>
                    <Textarea
                    placeholder="Digite seu comentário..."
                    maxLength={200}
                    onChange={handleCommentUser}                    
                    />
                   
                    <span className={count >= 170 ? styles.warning : ""}>
                    {count} / 200 caracteres
                    </span>
                    
                    <button className={styles.button}
                            disabled={ !session?.user }
                    >{ session?.user ? "Enviar comentário" : "Faça login para enviar comentário"}
                    </button>
                </form>
            </section>

            </main>
        </div>
    )
}

//Aqui não precisa usar o useEffect, a informação pode ser trazida do servidor (server side)
// Os dois pontos é para usar a tipagem do typescript
export const getServerSideProps: GetServerSideProps = async ( {params} )=>{
    // params? com interrogação  caso o usuário tente acessar digitando algo no link
    const idTask = params?.id as string;
    //console.log("Id recebido no [id].tsx: ",id);//Veja no TERMINAL ao atualizar uma página task
    
    //Pull dos detalhes da tarefa no servidor
    const docRef = doc(db, 'nexttask', idTask);
    //Buscar informação do BD
    const snapshot = await getDoc(docRef);

    //Fazer a verificação
    if( snapshot.data() === undefined && !snapshot.data()?.public ){ //Se ele não encontrar tarefa. Caso tente digitar algo que não existe direcionar para home, por isso usar o "permanent: false"
        return{
            redirect: {
                destination: '/',
                permanent: false
            }
        }
    }
//IMPORTANTÍSSIMO
//Outros usuários acessar apenas tarefas PÚBLICAS. "public" foi o nome dado no BD.            
    if( !snapshot.data()?.public ){//Se NÃO for pública:
        return{
            redirect: {
                destination: '/',
                permanent: false
            }
        }
    }
   // console.log(snapshot.data()); //Veja no TERMINAL ao atualizar uma página task

    /*Obviamente que poderia ter sido feito assim:
    if( snapshot.data() === undefined && !snapshot.data()?.public )  
    Foram separados apenas para entendimento*/

//A data está vindo como Timestamp, exemplo, 20032023. Converter created com data formatada, 20/03/2023.
    const miliseconds = snapshot.data()?.created?.seconds * 1000;
    const task = {
        tarefa: snapshot.data()?.tarefa,
        public: snapshot.data()?.public,
        created: new Date( miliseconds ).toLocaleDateString(),
        user: snapshot.data()?.user,
        taskId: idTask
    }
    console.log(task);



    return{
        props: { //Enviar objetos para a página task
            item: task,
        }
    }
}






-------------------------Próximo passo é exibir esses comentários abaixo da parte de edição
Precisa buscar todos os comentários que tenham o mesmo taskId








import { GetServerSideProps } from "next";
import Head from "next/head";
import styles from './styles.module.css';

//Pull dos detalhes da tarefa no servidor
import { db } from "@/services/firebaseConnection";
import { doc, collection, query, where, getDoc, addDoc, getDocs } from 'firebase/firestore'; // getDocs com 's'. No plural para pegar TODOS os documentos.

//CRIAR A PARTE DE COMENTÁRIOS.
import { Textarea } from "@/components/textarea";

//Permitir na postagem somente o nome do usuário com cadastro.
//Limitar comentários
import { ChangeEvent, FormEvent, useState } from 'react';
import { useSession } from "next-auth/react";


//Enviar objetos para a página task. Tipagem para "item"
interface TaskProps{
    item: {//Dentro dele tem as propriedades que foram exibidas no terminal em console.log(task);
        tarefa: string,
        public: boolean,
        created: string,
        user: string,
        taskId: string
    } //Para saber o que cada um é (bool, string) basta olhar no terminal com console.log(task); habilitado
    
    //exibir esses comentários abaixo da parte de edição. Passar como array por ser uma lista. Precisa criar uma const[coments] em Task
    allComments: CommentProps[]
    
}



//exibir esses comentários abaixo da parte de edição. Pasar o que vai ter nela. Veja como aparece no BD uma mensagem ja criada
interface CommentProps{
    id: string,
    comment: string,
    taskId: string,
    user: string,
    name: string,
}





//Enviar objetos para a página task. Precisa acrescentar item na função. O typescript quer saber o que tem nele, criar uma tipagem para ele
//export default function Task(  {item}  ){
//Passada a tipagem, agora item vai respeitar ela acrescentando TaskProps
//exibir comentários abaixo da parte de edição passando allComments. Vai reclamar any, tipar ele com interface TaskProps{
export default function Task( {item, allComments}:TaskProps ){


//passar o texto para a variável input para poder colocar o nome do user nas mensagens
    const [input, setInput] = useState('');   

//Limitar comentários
    const [comment, setComment] = useState('');
    
    const handleCommentUser = (event: React.ChangeEvent<HTMLTextAreaElement>) => {
        setComment(event.target.value);
        setInput(event.target.value);
      };    
    const count = comment.length;//Até aqui para limitar comentários e adicionar em Textarea: 
      //maxLength={200} 
      //onChange={handleCommentChange}

//Permitir na postagem somente o nome do usuário com cadastro. Usar disable={true} no botão para permitir somente logados
    const { data: session } = useSession();


    //exibir esses comentários abaixo da parte de edição.
    //const [comments, setComments] = useState(allComments || []);// Vai iniciar com todos os comentários ou vazio. e Pode tipar ela 
    const [comments, setComments] = useState<CommentProps[]>(allComments || []); //Tipando ela fica blindada para não acontecer outra coisa que não seja o array dos objetos
//Tudo pronto. Agora é só utilizar abaixo de <section




//passar o texto para a variável input para poder colocar o nome do user nas mensagens
    async function handleComent( event: FormEvent ){
        event.preventDefault(); //Para não atualizar a página
        //alert('teste: function handleComent()')

        if ( input === "") return; //Não permitir comentários vazios
        if ( !session?.user?.email || !session?.user?.name) return; //Não permitir comentários sem nome ou email

        try {
            const docRef = await addDoc(collection(db, "comments"), { // Vai criar uma nova coleção para salvar comentários no BD com nome de ''comments'' 
              comment: input,
              created: new Date(),
              user: session?.user?.email,
              name: session?.user?.name,
              taskId: item?.taskId,
            }); //Acima é o cadastro no BD
            
             setInput('');  //Apagar o input após enviar
             setComment('')// Zerar o contador de caracteres
            

        } catch (err) {
            console.log(err);
          }
           
}


    return(
        <div className={styles.container}>
            <Head>
                <title>Detalhes da tarefa</title>
            </Head>

            <main className={styles.main}>
                <h1>Tarefa</h1>

                {/* //Enviar objetos para a página task. */}
                <article className={styles.task}>
                    <p>
                        {item.tarefa}
                    </p>
                </article>

             {/* CRIAR A PARTE DE COMENTÁRIOS. Vai ser interessante importar Textarea*/}
             <section className={styles.commentsContainer}>
                <h2>Deixar comentário</h2>
                <form onSubmit={handleComent}>
                    <Textarea
                    value={input}
                    placeholder="Digite seu comentário..."
                    maxLength={200}
                    onChange={handleCommentUser}                    
                    />
                   
                    <span className={count >= 170 ? styles.warning : ""}>
                    {count} / 200 caracteres
                    </span>
                    
                    <button className={styles.button}
                            disabled={ !session?.user }
                    >{ session?.user ? "Enviar comentário" : "Faça login para enviar comentário"}
                    </button>
                </form>
            </section>


            {/* //exibir esses comentários abaixo da parte de edição. LEMBRAR DE PASSAR A PROPRIEDADE KEY*/}
            <section className={styles.commentsContainer}>
                <h2>Todos os comentários</h2>

                {comments.length === 0 && (<span>Nenhun comentário foi encontrado...</span>)}

                {comments.map( ( item )=>(
                    <article key={ item.id } className={styles.comment}>
                        <p>{item.comment}</p>
                    </article>
                ))}

            </section>

            </main>
        </div>
    )
}

//Aqui não precisa usar o useEffect, a informação pode ser trazida do servidor (server side)
// Os dois pontos é para usar a tipagem do typescript
export const getServerSideProps: GetServerSideProps = async ( {params} )=>{
    // params? com interrogação  caso o usuário tente acessar digitando algo no link
    const idTask = params?.id as string;
    //console.log("Id recebido no [id].tsx: ",id);//Veja no TERMINAL ao atualizar uma página task
    
    //Pull dos detalhes da tarefa no servidor
    const docRef = doc(db, 'nexttask', idTask);
    //Buscar informação do BD
    const snapshot = await getDoc(docRef);


    //exibir esses comentários abaixo da parte de edição. taskId foi o nome dado no BD. --> onde taskID for igual ao id da tarefa que é idTask 
    const q = query(collection(db, 'comments'), where('taskId', '==', idTask));
    const snapshotComments = await getDocs(q); // getDocs com 's'. No plural para pegar TODOS os documentos.
    //o snapshotComments vai recever tudo. Agora montar o array como será exibido
    //let allComments = []; //Dessa forma vai pedir uma tipagem para não ficar any, ela não sabe o que ela é ainda. Fazer a interface acima de Task()
    let allComments: CommentProps[] = []; //Se passar o mouse sobre ele, vai mostrar como array
    //Aqui terá o retorno. Usar forEach para percorrer todos eles
    snapshotComments.forEach( (doc)=> {
        allComments.push( {
            id: doc.id,
            comment: doc.data().comment,
            taskId: doc.data().taskId,
            user: doc.data().user,
            name: doc.data().name            
        })
    }) 
    // VEJA NO TERMINAL
   // console.log(allComments); //Para saber se está passando todos os comentários. Passar allComments para o componente return{ props  e também para Task()

    //Fazer a verificação
    if( snapshot.data() === undefined && !snapshot.data()?.public ){ //Se ele não encontrar tarefa. Caso tente digitar algo que não existe direcionar para home, por isso usar o "permanent: false"
        return{
            redirect: {
                destination: '/',
                permanent: false
            }
        }
    }
//IMPORTANTÍSSIMO
//Outros usuários acessar apenas tarefas PÚBLICAS. "public" foi o nome dado no BD.            
    if( !snapshot.data()?.public ){//Se NÃO for pública:
        return{
            redirect: {
                destination: '/',
                permanent: false
            }
        }
    }
   // console.log(snapshot.data()); //Veja no TERMINAL ao atualizar uma página task

    /*Obviamente que poderia ter sido feito assim:
    if( snapshot.data() === undefined && !snapshot.data()?.public )  
    Foram separados apenas para entendimento*/

//A data está vindo como Timestamp, exemplo, 20032023. Converter created com data formatada, 20/03/2023.
    const miliseconds = snapshot.data()?.created?.seconds * 1000;
    const task = {
        tarefa: snapshot.data()?.tarefa,
        public: snapshot.data()?.public,
        created: new Date( miliseconds ).toLocaleDateString(),
        user: snapshot.data()?.user,
        taskId: idTask
    }
    console.log(task);



    return{
        props: { //Enviar objetos para a página task, //exibir comentários abaixo da parte de edição.
            item: task,
            allComments: allComments
        }
    }
}





----------------Estilizar comentários em [id].tsx



{/* //exibir esses comentários abaixo da parte de edição. LEMBRAR DE PASSAR A PROPRIEDADE KEY*/}
            <section className={styles.commentsContainer}>
                <h2>Todos os comentários</h2>

                {comments.length === 0 && (<span>Nenhun comentário foi encontrado...</span>)}

                {comments.map( ( item )=>(
                    <article key={ item.id } className={styles.comment}>
                        <div className={styles.headComment}>
                            <label className={styles.commentsLabel}>{item.name}</label>
                            <button className={styles.buttonTrash}>
                                <FaTrash size={18} color='#ea3140'/> 
                            </button>
                        </div>
                        <p>{item.comment}</p>
                    </article>
                ))}

            </section>



--------------Css do [id].tsx:


.container{
    width: 100%;
    max-width: 1024px;
    margin: 40px auto 0 auto; /* até aqui vai alinhar tudo */
    padding: 0 18px;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center; /* até aqui vai centralizaar tudo na página */
}

.main{
    width: 100%;/* ele está dentro do container de no máximo 1024px */
}

.main h1{
    margin-bottom: 15px;
}

 /* Crie uma tarefa com texto grande  https://www.lipsum.com/
 */

.task{
    border: 1.5px solid #909090;
    padding: 15px;
    line-height: 100%; /* Para distanciar quebra de linha */
    border-radius: 5px;
    display: flex;   
    justify-content: center;
    align-items: center;
}

.task p{
    white-space: pre-wrap; /* Para quebrar de linha */
    width: 100%;
} /* Veja como fico responsivo. Show de bola */

/* Parte dos comentários */
.comentsContainer{
    margin: 18px 0;
    width: 100%;
    max-width: 1024px;
}

.comentsContainer h2{
    margin: 15px 0;
}

.button{
    width: 100%;
    padding: 10px 0;
    border-radius: 5px;
    border: 0;
    color: #fff;
    background-color: #3183ff;
    font-size: 18px;
    cursor: pointer;
}

/*  Limitar comentários */
.warning {
    color: rgb(255, 0, 0);
  }

  /* //Permitir na postagem somente o nome do usuário com cadastro. 
  Usar disabled={true} para testar css e depois substituir o true por disabled={ !session?.user }
  
  no botão permitir somente logados e
  acertar isso no CSS com tom de cor mais fraco para "desabilitado"*/
  .button:disabled {
    cursor: not-allowed;
    background-color: rgba(49, 131, 255, 0.421);
    color: rgba(255, 0, 0, 0.69);
  }



  /*exibir comentários abaixo da parte de edição.*/
.comment{
    border: 1px solid #ddd;
    padding: 15px;
    border-radius: 5px;
    margin-bottom: 15px;
}

.comment p {
    margin-top: 15px;
    white-space: pre-wrap;

}

.headComment{
    display: flex;
    align-items: center;
}

.commentsLabel{
    background-color: #CCC;
    padding: 4px 8px;
    border-radius: 5px;
    margin-right: 5px;
}

.buttonTrash{
    border: 0;
    background: transparent;
    cursor: pointer;
}





-------------[id].tsx
Deixar o botão excluir somente do usuário logado, 
sem ter o botão lixeira aparecendo de outro usuário




{comments.map((item) => (
                        <article key={item.id} className={styles.comment}>
                            <div className={styles.headComment}>
                                <label className={styles.commentsLabel}>{item.name}</label>

                                {/* Deixar o botão excluir somente do usuário logado, 
                                    sem ter o botão lixeira aparecendo de outro usuário                                
                                Se o email do comentário for igual ao do que está logado exibir lixeira de excluir */}
                                {item.user === session?.user?.email && (

                                    <button className={styles.buttonTrash}>
                                        <FaTrash size={18} color='#ea3140' />
                                    </button>
                                )}


                            </div>
                            <p>{item.comment}</p>
                        </article>
                    ))}




-------------[id].tsx
Depois de registrar atualizar a lista automaticamente.
Registrar chama o handleCommente() e depois limpa o input. Adicionar mais uma tarefa:







import { GetServerSideProps } from "next";
import Head from "next/head";
import styles from './styles.module.css';

//Pull dos detalhes da tarefa no servidor
import { db } from "@/services/firebaseConnection";
import { doc, collection, query, where, getDoc, addDoc, getDocs } from 'firebase/firestore'; // getDocs com 's'. No plural para pegar TODOS os documentos.

//CRIAR A PARTE DE COMENTÁRIOS.
import { Textarea } from "@/components/textarea";

//Permitir na postagem somente o nome do usuário com cadastro.
//Limitar comentários
import { ChangeEvent, FormEvent, useState } from 'react';
import { useSession } from "next-auth/react";
import { FaTrash } from "react-icons/fa";


//Enviar objetos para a página task. Tipagem para "item"
interface TaskProps {
    item: {//Dentro dele tem as propriedades que foram exibidas no terminal em console.log(task);
        tarefa: string,
        public: boolean,
        created: string,
        user: string,
        taskId: string
    } //Para saber o que cada um é (bool, string) basta olhar no terminal com console.log(task); habilitado

    //exibir esses comentários abaixo da parte de edição. Passar como array por ser uma lista. Precisa criar uma const[coments] em Task
    allComments: CommentProps[]

}



//exibir esses comentários abaixo da parte de edição. Pasar o que vai ter nela. Veja como aparece no BD uma mensagem ja criada
interface CommentProps {
    id: string,
    comment: string,
    taskId: string,
    user: string,
    name: string,
}





//Enviar objetos para a página task. Precisa acrescentar item na função. O typescript quer saber o que tem nele, criar uma tipagem para ele
//export default function Task(  {item}  ){
//Passada a tipagem, agora item vai respeitar ela acrescentando TaskProps
//exibir comentários abaixo da parte de edição passando allComments. Vai reclamar any, tipar ele com interface TaskProps{
export default function Task({ item, allComments }: TaskProps) {


    //passar o texto para a variável input para poder colocar o nome do user nas mensagens
    const [input, setInput] = useState('');

    //Limitar comentários
    const [comment, setComment] = useState('');

    const handleCommentUser = (event: React.ChangeEvent<HTMLTextAreaElement>) => {
        setComment(event.target.value);
        setInput(event.target.value);
    };
    const count = comment.length;//Até aqui para limitar comentários e adicionar em Textarea: 
    //maxLength={200} 
    //onChange={handleCommentChange}

    //Permitir na postagem somente o nome do usuário com cadastro. Usar disable={true} no botão para permitir somente logados
    const { data: session } = useSession();


    //exibir esses comentários abaixo da parte de edição.
    //const [comments, setComments] = useState(allComments || []);// Vai iniciar com todos os comentários ou vazio. e Pode tipar ela 
    const [comments, setComments] = useState<CommentProps[]>(allComments || []); //Tipando ela fica blindada para não acontecer outra coisa que não seja o array dos objetos
    //Tudo pronto. Agora é só utilizar abaixo de <section




    //passar o texto para a variável input para poder colocar o nome do user nas mensagens
    async function handleComent(event: FormEvent) {
        event.preventDefault(); //Para não atualizar a página
        //alert('teste: function handleComent()')

        if (input === "") return; //Não permitir comentários vazios
        if (!session?.user?.email || !session?.user?.name) return; //Não permitir comentários sem nome ou email

        try {
            const docRef = await addDoc(collection(db, "comments"), { // Vai criar uma nova coleção para salvar comentários no BD com nome de ''comments'' 
                comment: input,
                created: new Date(),
                user: session?.user?.email,
                name: session?.user?.name,
                taskId: item?.taskId,
            }); //Acima é o cadastro no BD

           // Depois de registrar atualizar a lista automaticamente. O comment foi digitado no input
            const data = {
                id: docRef.id,
                comment: input,
                user: session?.user?.email,
                name: session?.user?.name,
                taskId: item?.taskId
            }//Manter esse comentário e adicionar a mais com data. Passar tudo para uma useState de comentários
            setComments( (oldItens)=>[ ...oldItens, data ]);


            setInput('');  //Apagar o input após enviar
            setComment('')// Zerar o contador de caracteres


        } catch (err) {
            console.log(err);
        }

    }


    return (
        <div className={styles.container}>
            <Head>
                <title>Detalhes da tarefa</title>
            </Head>

            <main className={styles.main}>
                <h1>Tarefa</h1>

                {/* //Enviar objetos para a página task. */}
                <article className={styles.task}>
                    <p>
                        {item.tarefa}
                    </p>
                </article>

                {/* CRIAR A PARTE DE COMENTÁRIOS. Vai ser interessante importar Textarea*/}
                <section className={styles.commentsContainer}>
                    <h2>Deixar comentário</h2>
                    <form onSubmit={handleComent}>
                        <Textarea
                            value={input}
                            placeholder="Digite seu comentário..."
                            maxLength={200}
                            onChange={handleCommentUser}
                        />

                        <span className={count >= 170 ? styles.warning : ""}>
                            {count} / 200 caracteres
                        </span>

                        <button className={styles.button}
                            disabled={!session?.user}
                        >{session?.user ? "Enviar comentário" : "Faça login para enviar comentário"}
                        </button>
                    </form>
                </section>


                {/* //exibir esses comentários abaixo da parte de edição. LEMBRAR DE PASSAR A PROPRIEDADE KEY*/}
                <section className={styles.commentsContainer}>
                    <h2>Todos os comentários</h2>

                    {comments.length === 0 && (<span>Nenhun comentário foi encontrado...</span>)}

                    {comments.map((item) => (
                        <article key={item.id} className={styles.comment}>
                            <div className={styles.headComment}>
                                <label className={styles.commentsLabel}>{item.name}</label>

                                {/* Deixar o botão excluir somente do usuário logado, 
                                    sem ter o botão lixeira aparecendo de outro usuário                                
                                Se o email do comentário for igual ao do que está logado exibir lixeira de excluir */}
                                {item.user === session?.user?.email && (

                                    <button className={styles.buttonTrash}>
                                        <FaTrash size={18} color='#ea3140' />
                                    </button>
                                )}


                            </div>
                            <p>{item.comment}</p>
                        </article>
                    ))}

                </section>

            </main>
        </div>
    )
}

//Aqui não precisa usar o useEffect, a informação pode ser trazida do servidor (server side)
// Os dois pontos é para usar a tipagem do typescript
export const getServerSideProps: GetServerSideProps = async ({ params }) => {
    // params? com interrogação  caso o usuário tente acessar digitando algo no link
    const idTask = params?.id as string;
    //console.log("Id recebido no [id].tsx: ",id);//Veja no TERMINAL ao atualizar uma página task

    //Pull dos detalhes da tarefa no servidor
    const docRef = doc(db, 'nexttask', idTask);
    //Buscar informação do BD
    const snapshot = await getDoc(docRef);


    //exibir esses comentários abaixo da parte de edição. taskId foi o nome dado no BD. --> onde taskID for igual ao id da tarefa que é idTask 
    const q = query(collection(db, 'comments'), where('taskId', '==', idTask));
    const snapshotComments = await getDocs(q); // getDocs com 's'. No plural para pegar TODOS os documentos.
    //o snapshotComments vai recever tudo. Agora montar o array como será exibido
    //let allComments = []; //Dessa forma vai pedir uma tipagem para não ficar any, ela não sabe o que ela é ainda. Fazer a interface acima de Task()
    let allComments: CommentProps[] = []; //Se passar o mouse sobre ele, vai mostrar como array
    //Aqui terá o retorno. Usar forEach para percorrer todos eles
    snapshotComments.forEach((doc) => {
        allComments.push({
            id: doc.id,
            comment: doc.data().comment,
            taskId: doc.data().taskId,
            user: doc.data().user,
            name: doc.data().name
        })
    })
    // VEJA NO TERMINAL
    // console.log(allComments); //Para saber se está passando todos os comentários. Passar allComments para o componente return{ props  e também para Task()

    //Fazer a verificação
    if (snapshot.data() === undefined && !snapshot.data()?.public) { //Se ele não encontrar tarefa. Caso tente digitar algo que não existe direcionar para home, por isso usar o "permanent: false"
        return {
            redirect: {
                destination: '/',
                permanent: false
            }
        }
    }
    //IMPORTANTÍSSIMO
    //Outros usuários acessar apenas tarefas PÚBLICAS. "public" foi o nome dado no BD.            
    if (!snapshot.data()?.public) {//Se NÃO for pública:
        return {
            redirect: {
                destination: '/',
                permanent: false
            }
        }
    }
    // console.log(snapshot.data()); //Veja no TERMINAL ao atualizar uma página task

    /*Obviamente que poderia ter sido feito assim:
    if( snapshot.data() === undefined && !snapshot.data()?.public )  
    Foram separados apenas para entendimento*/

    //A data está vindo como Timestamp, exemplo, 20032023. Converter created com data formatada, 20/03/2023.
    const miliseconds = snapshot.data()?.created?.seconds * 1000;
    const task = {
        tarefa: snapshot.data()?.tarefa,
        public: snapshot.data()?.public,
        created: new Date(miliseconds).toLocaleDateString(),
        user: snapshot.data()?.user,
        taskId: idTask
    }
    console.log(task);



    return {
        props: { //Enviar objetos para a página task, //exibir comentários abaixo da parte de edição.
            item: task,
            allComments: allComments
        }
    }
}



---------------deletar os comentários em [id].tsx



  //deletar os comentários. Importar deleteDoc. "comments" é a collection criada no BD
    async function handleDeleteComments(id: string) {

        try {

            const docRef = doc(db, "comments", id); //Essa é a referência a ser deletada. Deletar:
            await deleteDoc( docRef );

            alert("Comentário apagado");

        } catch (err) {
            console.log(err);
        }
    }//Essa função precisa ser chamada no botão deletar como onClick={ ()=> handleDeleteComments( item.id )}




-------------Comentários foi apagado agora precisa informar para useState que foi apagado:




    //deletar os comentários. Importar deleteDoc. "comments" é a collection criada no BD
    async function handleDeleteComments(id: string) {

        try {

            const docRef = doc(db, "comments", id); //Essa é a referência a ser deletada. Deletar:
            await deleteDoc( docRef );

           // alert("Comentário apagado");

           //Comentários foi apagado agora precisa informar para useState que foi apagado. filter() Vai percorrer todos os itens dos comentarios
           const deleteComment = comments.filter( ( item )=> item.id !== id );

           console.log(deleteComment);



        } catch (err) {
            console.log(err);
        }
    }//Essa função precisa ser chamada no botão deletar como onClick={ ()=> handleDeleteComments( item.id )}




------------------Finalizado a parte [id].tsx. Ficou assim:



import { GetServerSideProps } from "next";
import Head from "next/head";
import styles from './styles.module.css';

//Pull dos detalhes da tarefa no servidor
import { db } from "@/services/firebaseConnection";
import { doc, collection, query, where, getDoc, addDoc, getDocs, deleteDoc } from 'firebase/firestore'; // getDocs com 's'. No plural para pegar TODOS os documentos.

//CRIAR A PARTE DE COMENTÁRIOS.
import { Textarea } from "@/components/textarea";

//Permitir na postagem somente o nome do usuário com cadastro.
//Limitar comentários
import { ChangeEvent, FormEvent, useState } from 'react';
import { useSession } from "next-auth/react";
import { FaTrash } from "react-icons/fa";


//Enviar objetos para a página task. Tipagem para "item"
interface TaskProps {
    item: {//Dentro dele tem as propriedades que foram exibidas no terminal em console.log(task);
        tarefa: string,
        public: boolean,
        created: string,
        user: string,
        taskId: string
    } //Para saber o que cada um é (bool, string) basta olhar no terminal com console.log(task); habilitado

    //exibir esses comentários abaixo da parte de edição. Passar como array por ser uma lista. Precisa criar uma const[coments] em Task
    allComments: CommentProps[]

}



//exibir esses comentários abaixo da parte de edição. Pasar o que vai ter nela. Veja como aparece no BD uma mensagem ja criada
interface CommentProps {
    id: string,
    comment: string,
    taskId: string,
    user: string,
    name: string,
}





//Enviar objetos para a página task. Precisa acrescentar item na função. O typescript quer saber o que tem nele, criar uma tipagem para ele
//export default function Task(  {item}  ){
//Passada a tipagem, agora item vai respeitar ela acrescentando TaskProps
//exibir comentários abaixo da parte de edição passando allComments. Vai reclamar any, tipar ele com interface TaskProps{
export default function Task({ item, allComments }: TaskProps) {


    //passar o texto para a variável input para poder colocar o nome do user nas mensagens
    const [input, setInput] = useState('');

    //Limitar comentários
    const [comment, setComment] = useState('');

    const handleCommentUser = (event: React.ChangeEvent<HTMLTextAreaElement>) => {
        setComment(event.target.value);
        setInput(event.target.value);
    };
    const count = comment.length;//Até aqui para limitar comentários e adicionar em Textarea: 
    //maxLength={200} 
    //onChange={handleCommentChange}

    //Permitir na postagem somente o nome do usuário com cadastro. Usar disable={true} no botão para permitir somente logados
    const { data: session } = useSession();


    //exibir esses comentários abaixo da parte de edição.
    //const [comments, setComments] = useState(allComments || []);// Vai iniciar com todos os comentários ou vazio. e Pode tipar ela 
    const [comments, setComments] = useState<CommentProps[]>(allComments || []); //Tipando ela fica blindada para não acontecer outra coisa que não seja o array dos objetos
    //Tudo pronto. Agora é só utilizar abaixo de <section




    //passar o texto para a variável input para poder colocar o nome do user nas mensagens
    async function handleComent(event: FormEvent) {
        event.preventDefault(); //Para não atualizar a página
        //alert('teste: function handleComent()')

        if (input === "") return; //Não permitir comentários vazios
        if (!session?.user?.email || !session?.user?.name) return; //Não permitir comentários sem nome ou email

        try {
            const docRef = await addDoc(collection(db, "comments"), { // Vai criar uma nova coleção para salvar comentários no BD com nome de ''comments'' 
                comment: input,
                created: new Date(),
                user: session?.user?.email,
                name: session?.user?.name,
                taskId: item?.taskId,
            }); //Acima é o cadastro no BD

            // Depois de registrar atualizar a lista automaticamente. O comment foi digitado no input
            const data = {
                id: docRef.id,
                comment: input,
                user: session?.user?.email,
                name: session?.user?.name,
                taskId: item?.taskId
            }//Manter esse comentário e adicionar a mais com data. Passar tudo para uma useState de comentários
            setComments((oldItens) => [...oldItens, data]);


            setInput('');  //Apagar o input após enviar
            setComment('')// Zerar o contador de caracteres


        } catch (err) {
            console.log(err);
        }

    }


    //deletar os comentários. Importar deleteDoc. "comments" é a collection criada no BD
    async function handleDeleteComments(id: string) {

        try {

            const docRef = doc(db, "comments", id); //Essa é a referência a ser deletada. Deletar:
            await deleteDoc(docRef);

            // alert("Comentário apagado");

            //Comentários foi apagado agora precisa informar para useState que foi apagado. filter() Vai percorrer todos os itens dos comentarios
            const deleteComment = comments.filter((item) => item.id !== id);//Deixar apenas os que NÃO clicou deletar

            //console.log(deleteComment);//Conferido. Agora passar para useState
            setComments(deleteComment);


        } catch (err) {
            console.log(err);
        }
    }//Essa função precisa ser chamada no botão deletar como onClick={ ()=> handleDeleteComments( item.id )}



    return (
        <div className={styles.container}>
            <Head>
                <title>Detalhes da tarefa</title>
            </Head>

            <main className={styles.main}>
                <h1>Tarefa</h1>

                {/* //Enviar objetos para a página task. */}
                <article className={styles.task}>
                    <p>
                        {item.tarefa}
                    </p>
                </article>

                {/* CRIAR A PARTE DE COMENTÁRIOS. Vai ser interessante importar Textarea*/}
                <section className={styles.commentsContainer}>
                    <h2>Deixar comentário</h2>
                    <form onSubmit={handleComent}>
                        <Textarea
                            value={input}
                            placeholder="Digite seu comentário..."
                            maxLength={200}
                            onChange={handleCommentUser}
                        />

                        <span className={count >= 170 ? styles.warning : ""}>
                            {count} / 200 caracteres
                        </span>

                        <button className={styles.button}
                            disabled={!session?.user}
                        >{session?.user ? "Enviar comentário" : "Faça login para enviar comentário"}
                        </button>
                    </form>
                </section>


                {/* //exibir esses comentários abaixo da parte de edição. LEMBRAR DE PASSAR A PROPRIEDADE KEY*/}
                <section className={styles.commentsContainer}>
                    <h2>Todos os comentários</h2>

                    {comments.length === 0 && (<span>Nenhun comentário foi encontrado...</span>)}

                    {comments.map((item) => (
                        <article key={item.id} className={styles.comment}>
                            <div className={styles.headComment}>
                                <label className={styles.commentsLabel}>{item.name}</label>

                                {/* Deixar o botão excluir somente do usuário logado, 
                                    sem ter o botão lixeira aparecendo de outro usuário                                
                                Se o email do comentário for igual ao do que está logado exibir lixeira de excluir */}
                                {item.user === session?.user?.email && (

                                    <button className={styles.buttonTrash} onClick={() => handleDeleteComments(item.id)}>
                                        <FaTrash size={18} />
                                    </button>
                                )}


                            </div>
                            <p>{item.comment}</p>
                        </article>
                    ))}

                </section>

            </main>
        </div>
    )
}

//Aqui não precisa usar o useEffect, a informação pode ser trazida do servidor (server side)
// Os dois pontos é para usar a tipagem do typescript
export const getServerSideProps: GetServerSideProps = async ({ params }) => {
    // params? com interrogação  caso o usuário tente acessar digitando algo no link
    const idTask = params?.id as string;
    //console.log("Id recebido no [id].tsx: ",id);//Veja no TERMINAL ao atualizar uma página task

    //Pull dos detalhes da tarefa no servidor
    const docRef = doc(db, 'nexttask', idTask);
    //Buscar informação do BD
    const snapshot = await getDoc(docRef);


    //exibir esses comentários abaixo da parte de edição. taskId foi o nome dado no BD. --> onde taskID for igual ao id da tarefa que é idTask 
    const q = query(collection(db, 'comments'), where('taskId', '==', idTask));
    const snapshotComments = await getDocs(q); // getDocs com 's'. No plural para pegar TODOS os documentos.
    //o snapshotComments vai recever tudo. Agora montar o array como será exibido
    //let allComments = []; //Dessa forma vai pedir uma tipagem para não ficar any, ela não sabe o que ela é ainda. Fazer a interface acima de Task()
    let allComments: CommentProps[] = []; //Se passar o mouse sobre ele, vai mostrar como array
    //Aqui terá o retorno. Usar forEach para percorrer todos eles
    snapshotComments.forEach((doc) => {
        allComments.push({
            id: doc.id,
            comment: doc.data().comment,
            taskId: doc.data().taskId,
            user: doc.data().user,
            name: doc.data().name
        })
    })
    // VEJA NO TERMINAL
    // console.log(allComments); //Para saber se está passando todos os comentários. Passar allComments para o componente return{ props  e também para Task()

    //Fazer a verificação
    if (snapshot.data() === undefined && !snapshot.data()?.public) { //Se ele não encontrar tarefa. Caso tente digitar algo que não existe direcionar para home, por isso usar o "permanent: false"
        return {
            redirect: {
                destination: '/',
                permanent: false
            }
        }
    }
    //IMPORTANTÍSSIMO
    //Outros usuários acessar apenas tarefas PÚBLICAS. "public" foi o nome dado no BD.            
    if (!snapshot.data()?.public) {//Se NÃO for pública:
        return {
            redirect: {
                destination: '/',
                permanent: false
            }
        }
    }
    // console.log(snapshot.data()); //Veja no TERMINAL ao atualizar uma página task

    /*Obviamente que poderia ter sido feito assim:
    if( snapshot.data() === undefined && !snapshot.data()?.public )  
    Foram separados apenas para entendimento*/

    //A data está vindo como Timestamp, exemplo, 20032023. Converter created com data formatada, 20/03/2023.
    const miliseconds = snapshot.data()?.created?.seconds * 1000;
    const task = {
        tarefa: snapshot.data()?.tarefa,
        public: snapshot.data()?.public,
        created: new Date(miliseconds).toLocaleDateString(),
        user: snapshot.data()?.user,
        taskId: idTask
    }
    console.log(task);



    return {
        props: { //Enviar objetos para a página task, //exibir comentários abaixo da parte de edição.
            item: task,
            allComments: allComments
        }
    }
}





---------------Página home pelo pages/index.tsx.

Trazer do lado do servidor as informações para atualizar os botões de 
postagens  e  comentários. Será feita de uma forma diferente do que já foi apresentada apenas para aprendizado

Poderia pegar do getServerSide e mostrar pronto. Pode ainda usar useEfect.

Como não é uma informação relevante, pode usar "geração de página estática"
Ao tipar ja importou automaticamente o GetStaticProps

*******Montado de forma estática depois tem que fazer o REVALIDATE...


import Head from 'next/head'
import styles from '../../styles/home.module.css'

//Pode usar <img> se quiser, mas o Next tem um modelo que carrega melhor, tem mais performance. Image
import Image from 'next/image';
import homeimage from '../../public/assets/home-image.jpg';
import { GetStaticProps } from 'next';
// Pode priorizar o carregamento escrevendo apenas priority. Não precisa ser priority={true}

//atualizar os botões de postagens  e  comentários
import { collection, getDocs } from 'firebase/firestore'; // getDocs com 's'. No plural para pegar TODOS os documentos.
import { db } from '@/services/firebaseConnection';

//atualizar os botões de postagens  e  comentários
interface HomeProps {//Vai receber as propriedades criadas em getStaticProps
  posts: number;
  comments: number;
}

export default function Home({ posts, comments }: HomeProps) { // tipado  { posts, comments }: HomeProps agora pode distribuir 
  return (
    <div className={styles.container}>
      <Head>
        <title>Tarefas+ | Organize de forma fácil</title>
      </Head>
      <main className={styles.main}>
        <div className={styles.logoContent}>
          <Image className={styles.homeimage}
            alt="Logo Tarefas"
            src={homeimage}
            priority={true}
          />
        </div>
        <h1 className={styles.title}>
          Organize seus estudos e outras tarefas
          <br />do dia a dia.
        </h1>

        <div className={styles.infoContent}>
          <section className={styles.box}>
            <span>+{posts} posts</span> {/* atualizar os botões de postagens  e  comentários */}
          </section>

          <section className={styles.box}>
            <span>+{comments} comentários</span> {/* atualizar os botões de postagens  e  comentários */}
          </section>
        </div>

      </main>

    </div>
  )
}



//atualizar os botões de postagens  e  comentários
export const getStaticProps: GetStaticProps = async () => {

  //Buscar do BD a contagem. Importar collection e getDocs. Importar db
  const commentRef = collection(db, 'comments');   //'comments' nome dado para collection no BD
  //Fazer o mesmo com as tarefas
  const postRef = collection(db, 'nexttask');

  const commentSnapshot = await getDocs(commentRef);//Aqui terá o resultado do documento
  const postSnapshot = await getDocs(postRef);

  return {
    props: {
      posts: postSnapshot.size || 0,
      comments: commentSnapshot.size || 0


    }//    commentSnapshot.size || 0     zero caso não tenha nada
  }//Receber isso para o componente export default function Home()
}






---------REVALIDATE na página pages/index.tsx para revalidar o número de postagens

LOCALMENTE funciona sem o 'revalidate', mas em produção PRECISA DELE

Exemplo, se em 60 segundos entrarem 400 usuários no site serão evitados 400 requisições 

Usar:

//REVALIDATE para revalidar o número de postagens
    revalidate: 60,  //Revalidada a cada 60 segundos. Qualquer dúvida veja aula 50


---------Finalizando a página ficou assim:




import Head from 'next/head'
import styles from '../../styles/home.module.css'

//Pode usar <img> se quiser, mas o Next tem um modelo que carrega melhor, tem mais performance. Image
import Image from 'next/image';
import homeimage from '../../public/assets/home-image.jpg';
import { GetStaticProps } from 'next';
// Pode priorizar o carregamento escrevendo apenas priority. Não precisa ser priority={true}

//atualizar os botões de postagens  e  comentários
import { collection, getDocs } from 'firebase/firestore'; // getDocs com 's'. No plural para pegar TODOS os documentos.
import { db } from '@/services/firebaseConnection';

//atualizar os botões de postagens  e  comentários
interface HomeProps {//Vai receber as propriedades criadas em getStaticProps
  posts: number;
  comments: number;
}

export default function Home({ posts, comments }: HomeProps) { // tipado  { posts, comments }: HomeProps agora pode distribuir 
  return (
    <div className={styles.container}>
      <Head>
        <title>Tarefas+ | Organize de forma fácil</title>
      </Head>
      <main className={styles.main}>
        <div className={styles.logoContent}>
          <Image className={styles.homeimage}
            alt="Logo Tarefas"
            src={homeimage}
            priority={true}
          />
        </div>
        <h1 className={styles.title}>
          Organize seus estudos e outras tarefas
          <br />do dia a dia.
        </h1>

        <div className={styles.infoContent}>
          <section className={styles.box}>
            <span>+{posts} posts</span> {/* atualizar os botões de postagens  e  comentários */}
          </section>

          <section className={styles.box}>
            <span>+{comments} comentários</span> {/* atualizar os botões de postagens  e  comentários */}
          </section>
        </div>

      </main>

    </div>
  )
}



//atualizar os botões de postagens  e  comentários
export const getStaticProps: GetStaticProps = async () => {

  //Buscar do BD a contagem. Importar collection e getDocs. Importar db
  const commentRef = collection(db, 'comments');   //'comments' nome dado para collection no BD
  //Fazer o mesmo com as tarefas
  const postRef = collection(db, 'nexttask');

  const commentSnapshot = await getDocs(commentRef);//Aqui terá o resultado do documento
  const postSnapshot = await getDocs(postRef);

  return {
    props: {   //    commentSnapshot.size || 0     zero caso não tenha nada
      posts: postSnapshot.size || 0,
      comments: commentSnapshot.size || 0


    },

    //REVALIDATE para revalidar o número de postagens
    revalidate: 60,  //Revalidada a cada 60 segundos


  }//Receber isso para o componente export default function Home()
}

























